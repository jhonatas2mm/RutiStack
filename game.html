<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Equilíbrio da Coruja</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0f0f1e;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        :root {
            --bg-grad: linear-gradient(180deg, #cfe9e3 0%, #a2d7e6 50%, #8bb6d9 100%);
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: var(--bg-grad);
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative;
            z-index: 1;
            /* Below the game-over modal */
            background: var(--bg-grad);
        }

        /* Ensure Phaser canvas stays transparent so gradient shows through */
        #game-container canvas {
            background: transparent !important;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .pixel-btn {
            background-color: #fff;
            border: 4px solid #fff;
            box-shadow: 4px 4px 0px #000;
            color: #000;
            font-family: 'Press Start 2P', cursive;
            padding: 15px 20px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            text-transform: uppercase;
            transition: transform 0.1s;
        }

        .pixel-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px #000;
        }

        @keyframes loading-gradient-cycle {
            0% {
                background: linear-gradient(180deg, #cfe9e3 0%, #a2d7e6 50%, #8bb6d9 100%);
            }

            33% {
                background: linear-gradient(180deg, #c9d4ff 0%, #f1c6ff 50%, #ffcad4 100%);
            }

            66% {
                background: linear-gradient(180deg, #ffcba4 0%, #ff9a9e 50%, #ff5f6d 100%);
            }

            100% {
                background: linear-gradient(180deg, #cfe9e3 0%, #a2d7e6 50%, #8bb6d9 100%);
            }
        }

        #bg-gradient-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            background: var(--bg-grad);
            /* will be updated dynamically */
        }

        .pixel-box {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #fff;
            padding: 20px;
            text-align: center;
            pointer-events: auto;
        }

        #lives-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            /* Moved to left */
            display: flex;
            gap: 5px;
            z-index: 100;
            pointer-events: none;
        }

        .heart-icon {
            width: 24px;
            height: 24px;
            image-rendering: pixelated;
        }

        #score-display {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            z-index: 100;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        #height-display {
            position: fixed;
            top: 60px;
            right: 20px;
            /* Moved to right under score */
            color: #00ffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            z-index: 100;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        .menu-btn {
            background: none;
            border: none;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            cursor: pointer;
            text-transform: uppercase;
            padding: 10px 30px;
            /* Add horizontal padding for arrow space */
            position: relative;
            transition: color 0.2s;
            text-align: center;
            width: auto;
            /* Fit content */
            white-space: nowrap;
        }

        .menu-btn:hover,
        .menu-btn.selected {
            color: #00ffff;
        }

        .menu-btn:hover::before,
        .menu-btn.selected::before {
            content: '> ';
            position: absolute;
            left: 0px;
            /* Position at the start of padding */
            color: #00ffff;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000a2e;
            background-image: url('assets/start_screen/background.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            /* Distribute horizontally */
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            padding: 0 50px;
            /* Add padding */
            box-sizing: border-box;
        }

        .start-left {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .start-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            /* height: 80%; Removed */
            /* flex: 1; Removed */
            position: relative;
        }

        .start-right {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .logo-icon {
            width: 120px;
            image-rendering: pixelated;
            animation: float 3s ease-in-out infinite;
            margin-bottom: 20px;
        }

        .logo-text {
            width: 300px;
            image-rendering: pixelated;
        }

        .anim-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: balance 2s ease-in-out infinite alternate;
            transform-origin: bottom center;
        }

        .char-owl {
            width: 250px;
            image-rendering: pixelated;
            z-index: 2;
            position: relative;
            top: 63px;
            /* Animation removed */
        }

        /* @keyframes flutter removed */

        /* Updated */

        .char-stack {
            /* width: 150px; Removed */
            height: 570px;
            /* Added */
            image-rendering: pixelated;
            /* margin-top: -10px; Removed */
            /* Synced animation */
            /* Pivot from bottom */
        }

        .start-btn {
            background: linear-gradient(180deg, #ff00cc, #ff6600);
            border: 4px solid #330066;
            box-shadow: 6px 6px 0px #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            padding: 25px 50px;
            /* Larger button */
            font-size: 28px;
            cursor: pointer;
            text-transform: uppercase;
            text-shadow: 3px 3px 0px #330066;
            transition: transform 0.1s;
        }

        .start-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 2px 2px 0px #000;
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }

            100% {
                transform: translateY(0px);
            }
        }

        @keyframes balance {
            0% {
                transform: rotate(-5deg);
            }

            100% {
                transform: rotate(5deg);
            }
        }



        /* Game Over Screen - Modal Overlay - Updated 00:10 */
        #game-over-screen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: linear-gradient(180deg, #cfe9e3 0%, #a2d7e6 50%, #8bb6d9 100%);
            animation: loading-gradient-cycle 3s ease-in-out infinite alternate;
            background-size: 100% 100%;
            justify-content: center !important;
            align-items: center !important;
            z-index: 10000 !important;
            pointer-events: auto;
        }

        .game-over-content {
            background: none;
            border: none;
            padding: 20px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            height: auto;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            z-index: 100 !important;
        }

        .hidden {
            display: none !important;
        }

        /* Name Input Styles */
        #name-input-container {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            column-gap: 18px;
            row-gap: 0;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .input-group {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            column-gap: 18px;
            row-gap: 0;
            width: 100%;
        }



        .char-input {
            width: 100%;
            height: 50px;
            background: #fff;
            border: 4px solid #fff;
            color: #000;
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            text-align: center;
            text-transform: uppercase;
            outline: none;
            caret-color: transparent;
            box-shadow: 4px 4px 0px #000;
        }

        .char-input:focus {
            outline: none;
            border-color: #000;
            animation: blink-focus 1s infinite;
        }

        @keyframes blink-focus {

            0%,
            100% {
                border-color: #00ffff;
            }

            50% {
                border-color: transparent;
            }
        }

        /* Admin Panel */
        #admin-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 1000;
            opacity: 0.7;
            transition: opacity 0.2s;
            background: linear-gradient(135deg, #4a6d8c 0%, #2a4d6c 100%);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.2);
            font-size: 0;
        }

        #admin-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background:
                linear-gradient(to right, transparent 6px, #00ffff 6px, #00ffff 10px, transparent 10px),
                linear-gradient(to bottom, transparent 6px, #00ffff 6px, #00ffff 10px, transparent 10px);
            background-size: 16px 16px;
        }

        #admin-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 12px;
            height: 12px;
            border: 2px solid #00ffff;
            background: transparent;
        }

        #admin-btn:hover {
            opacity: 1;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8), inset 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* Admin Palette (Neon Blue Theme) */
        :root {
            --gb-darkest: #000a2e;
            /* Deep Blue */
            --gb-dark: #1a1a40;
            /* Panel/Input BG */
            --gb-lightest: #00ffff;
            /* Neon Text/Border */
            --gb-bg: #0f0f1e;
            /* Main Overlay BG */
        }

        #admin-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gb-bg);
            z-index: 1001;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            pointer-events: auto;
            font-family: 'Press Start 2P', cursive;
            color: var(--gb-lightest);
            /* Changed to Lightest */
        }

        #admin-panel input {
            font-family: 'Press Start 2P', cursive;
            padding: 5px;
            margin-bottom: 5px;
            width: 100%;
            box-sizing: border-box;
            background: var(--gb-dark);
            /* Dark BG for inputs */
            color: #fff;
            /* White text for inputs */
            border: 1px solid var(--gb-lightest);
            /* Neon border */
        }

        #admin-panel label {
            font-size: 12px;
            color: var(--gb-lightest);
            /* Changed to Lightest */
            display: block;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .admin-header {
            color: var(--gb-lightest);
            /* Changed to Lightest */
            font-size: 32px;
            text-align: left;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .section-title {
            color: var(--gb-lightest);
            /* Changed to Lightest */
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            text-align: left;
            border-bottom: 2px solid var(--gb-lightest);
            /* Changed to Lightest */
            padding-bottom: 5px;
            width: 100%;
        }

        .admin-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 12px;
            border: 2px solid var(--gb-lightest);
            /* Changed to Lightest */
        }

        .admin-table th {
            text-align: left;
            padding: 10px;
            border: 1px solid var(--gb-lightest);
            background: var(--gb-dark);
            color: var(--gb-lightest);
        }

        .admin-table td {
            padding: 10px;
            border: 1px solid var(--gb-lightest);
            vertical-align: middle;
            background: transparent;
            color: #fff;
        }

        .admin-table input {
            width: 100%;
            background: var(--gb-dark);
            border: 1px solid var(--gb-lightest);
            color: #fff;
            padding: 5px;
            font-family: 'Press Start 2P', cursive;
            box-shadow: none;
        }

        .badge {
            display: inline-block;
            padding: 5px 10px;
            color: #fff;
            font-size: 10px;
            text-transform: uppercase;
            border: 1px solid #fff;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
        }

        .badge-normal {
            background-color: #4a6d8c;
            /* Muted Blue */
        }

        .badge-goal {
            background-color: #8c4a4a;
            /* Muted Red */
        }

        .admin-footer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: auto;
            gap: 20px;
        }

        .gb-input {
            width: 100%;
            background: var(--gb-dark);
            color: #fff;
            border: 1px solid var(--gb-lightest);
            padding: 10px;
            font-family: 'Press Start 2P';
            box-shadow: none;
        }

        .gb-btn {
            background-color: transparent;
            border: 2px solid var(--gb-lightest);
            box-shadow: none;
            color: var(--gb-lightest);
            font-family: 'Press Start 2P', cursive;
            padding: 15px 20px;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            flex: 1;
            transition: all 0.2s;
        }

        .gb-btn:hover {
            background-color: var(--gb-lightest);
            color: var(--gb-darkest);
        }

        .gb-btn:active {
            transform: translate(2px, 2px);
        }

        /* Responsive Adjustments */
        .table-container {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: auto;
            width: 100%;
            border: 2px solid var(--gb-darkest);
            margin-bottom: 20px;
        }

        .admin-controls-container {
            width: 95%;
            height: 95%;
            display: flex;
            flex-direction: column;
            max-width: none;
            /* Fluid */
        }

        @media (max-width: 768px) {
            .admin-header {
                font-size: 20px;
            }

            .section-title {
                font-size: 14px;
            }

            .gb-btn {
                padding: 10px;
                font-size: 10px;
            }

            .admin-table th,
            .admin-table td {
                padding: 5px;
                font-size: 10px;
            }

            .global-config-row {
                flex-direction: column;
                gap: 10px;
            }
        }



        /* Falling Broken Boxes */
        .falling-box {
            position: absolute;
            background-color: #fff;
            opacity: 0.3;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes fall {
            to {
                transform: translateY(110vh) rotate(360deg);
            }
        }

        @keyframes pulse-grow {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes pulse-shrink {

            0%,
            100% {
                transform: scale(1.1);
            }

            50% {
                transform: scale(1);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Mobile Responsiveness for Game Over Modal */
        @media (max-width: 600px) {
            .game-over-content {
                padding: 20px;
                width: 95%;
                max-height: 90vh;
            }

            .game-over-content img {
                width: 70% !important;
                /* More responsive text images */
                max-width: 150px !important;
            }

            #final-score {
                font-size: 24px !important;
                margin-bottom: 24px !important;
            }

            .char-input {
                width: 30px;
                height: 40px;
                font-size: 18px;
            }

            .pixel-btn {
                font-size: 14px;
                padding: 10px;
            }

            .menu-btn {
                font-size: 16px;
            }
        }



        .shortcut-key {
            opacity: 0.6;
            font-size: 0.8em;
            margin-left: 8px;
        }

        @keyframes score-milestone-anim {
            0% {
                transform: scale(1);
                color: #fff;
            }

            50% {
                transform: scale(1.5);
                color: #ffd700;
                text-shadow: 0 0 20px #ffd700;
            }

            100% {
                transform: scale(1);
                color: #fff;
            }
        }

        .score-milestone {
            animation: score-milestone-anim 0.5s ease-in-out;
        }
    </style>
</head>

<body>

    <!-- Dynamic Gradient Layer (behind the game canvas) -->
    <div id="bg-gradient-layer"></div>

    <!-- Loading Screen -->
    <div id="loading-screen"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(180deg, #cfe9e3 0%, #a2d7e6 50%, #8bb6d9 100%); animation: loading-gradient-cycle 6s ease-in-out infinite alternate; background-size: 100% 100%; display: flex; justify-content: center; align-items: center; z-index: 99999; flex-direction: column; gap: 30px;">
        <div
            style="background: none; padding: 40px; display: flex; flex-direction: column; align-items: center; gap: 30px;">
            <img src="assets/sprites/normal/1.png" alt="Loading"
                style="width: 128px; height: 128px; image-rendering: pixelated; animation: spin 2s linear infinite;">
            <div
                style="color: #ffffff; font-family: 'Press Start 2P'; font-size: 16px; animation: pulse 1.5s infinite; text-shadow: 2px 2px 0 #000;">
                CARREGANDO...</div>
        </div>
    </div>

    <style>
        @keyframes loading-gradient-cycle {
            0% {
                background: linear-gradient(180deg, #cfe9e3 0%, #a2d7e6 50%, #8bb6d9 100%);
            }

            50% {
                background: linear-gradient(180deg, #c9d4ff 0%, #f1c6ff 50%, #ffcad4 100%);
            }

            100% {
                background: linear-gradient(180deg, #ffcba4 0%, #ff9a9e 50%, #ff5f6d 100%);
            }
        }
    </style>

    <!-- Game Container -->
    <div id="game-container"></div>

    <!-- Damage Overlay (Red Flash) -->
    <div id="damage-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0; pointer-events: none; z-index: 900; transition: opacity 0.1s;">
    </div>

    <!-- UI Elements -->
    <div id="lives-display"></div>
    <div id="score-display">SCORE: 0</div>

    <!-- Top Buttons -->
    <div id="top-right-buttons"
        style="position: fixed; top: 20px; right: 20px; z-index: 999; display: flex; gap: 10px; align-items: center;">
        <button id="sound-btn"
            style="background: transparent; border: none; padding: 8px; cursor: pointer; pointer-events: auto;">
            <img id="sound-icon" src="assets/sprites/icons/audio.svg" alt="Sound" width="26" height="26"
                style="image-rendering: pixelated; filter: drop-shadow(3px 3px 0 #000); display: block;">
        </button>
        <button id="debug-btn" class="hidden"
            style="background: transparent; border: none; padding: 8px; cursor: pointer; pointer-events: auto;">
            <img src="assets/sprites/icons/settgings.svg" alt="Config" width="26" height="26"
                style="image-rendering: pixelated; filter: drop-shadow(3px 3px 0 #000); display: block;">
        </button>
        <button id="god-btn"
            style="padding: 8px 14px; font-size: 10px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000; font-family: 'Press Start 2P'; cursor: pointer; text-transform: uppercase;">
            GOD
        </button>
        <button id="exit-btn"
            style="padding: 8px 14px; font-size: 10px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000; font-family: 'Press Start 2P'; cursor: pointer; text-transform: uppercase;"
            onclick="window.location.href='index.html'">SAIR</button>
        <button id="reset-game-btn"
            style="padding: 8px 14px; font-size: 10px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000; font-family: 'Press Start 2P'; cursor: pointer; text-transform: uppercase;">
            RESET <span style="font-size: 8px; opacity: 0.7;">[R]</span>
        </button>
    </div>

    <!-- Start Screen -->
    <div id="instructionText"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ffffff; font-family: 'Press Start 2P'; font-size: 12px; pointer-events: none; z-index: 50; text-align: center; line-height: 1.5; text-shadow: 2px 2px 0 #000;">
        CLIQUE OU ESPAÇO<br>PARA SOLTAR
    </div>

    <!-- Game Over Screen moved to end of body for z-index -->

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, addDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        // --- FIREBASE CONFIGURATION ---
        // COLE SUA FIREBASE CONFIG AQUI
        const firebaseConfig = {
            apiKey: "AIzaSyCOAt0sfrDXeZgRYwA5UuTxayX3rr0ubyY",
            authDomain: "rutistack-c75f2.firebaseapp.com",
            projectId: "rutistack-c75f2",
            storageBucket: "rutistack-c75f2.firebasestorage.app",
            messagingSenderId: "401193886438",
            appId: "1:401193886438:web:5279b37e344ecfbbd35127",
            measurementId: "G-5NW50RJQN7"
        };

        let app, db, auth;
        let isFirebaseReady = false;

        try {
            if (firebaseConfig.apiKey) {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                isFirebaseReady = true;
                console.log("Firebase initialized.");
            } else {
                console.warn("Firebase config missing. Running in offline mode.");
            }
        } catch (e) {
            console.error("Firebase init error:", e);
        }

        // --- GAME CONFIGURATION ---
        let gameConfig = {
            gravity: 1,
            baseSpeed: 2.5,
            difficultyMultiplier: 0.1
        };

        let isDropping = false; // Flag to prevent double drops

        // Fetch Remote Config
        // Fetch Remote Config
        async function loadGameConfig() {
            // 1. Load Local (Fallback/Cache)
            const localConfig = localStorage.getItem('gameConfig');
            if (localConfig) {
                gameConfig = { ...gameConfig, ...JSON.parse(localConfig) };
                console.log("Local config loaded (cache):", gameConfig);
            }
            const localBoxTypes = localStorage.getItem('boxTypes');
            if (localBoxTypes) {
                // boxTypes = JSON.parse(localBoxTypes);
                // console.log("Local box types loaded (cache):", boxTypes);
            }

            if (!isFirebaseReady) return;

            try {
                // 2. Load Global Config from Firestore
                const configRef = doc(db, "settings", "gameConfig");
                const configSnap = await getDoc(configRef);

                if (configSnap.exists()) {
                    const data = configSnap.data();
                    gameConfig = { ...gameConfig, ...data };
                    console.log("Remote config loaded:", gameConfig);
                    localStorage.setItem('gameConfig', JSON.stringify(gameConfig));
                } else {
                    // Create default if not exists
                    await setDoc(configRef, gameConfig);
                    console.log("Remote config created with defaults.");
                }

                // 3. Load Box Types from Firestore
                const boxesRef = doc(db, "settings", "boxTypes");
                const boxesSnap = await getDoc(boxesRef);

                if (boxesSnap.exists()) {
                    const data = boxesSnap.data();
                    if (data.types) {
                        // boxTypes = data.types;
                        // console.log("Remote box types loaded:", boxTypes);
                        // localStorage.setItem('boxTypes', JSON.stringify(boxTypes));
                    }
                } else {
                    // Create default
                    await setDoc(boxesRef, { types: boxTypes });
                    console.log("Remote box types created with defaults.");
                }

            } catch (e) {
                console.error("Remote config error:", e);
            }
        }


        // Load Custom Sprites from Firestore (cached in localStorage)
        async function loadCustomSprites() {
            if (!isFirebaseReady) {
                console.log("Firebase offline - using cached sprites from localStorage");
                return;
            }

            try {
                for (const boxType of ['normal', 'goal']) {
                    const spritesRef = doc(db, "sprites", boxType);
                    const spritesSnap = await getDoc(spritesRef);

                    if (spritesSnap.exists()) {
                        const data = spritesSnap.data();
                        const spriteUrls = data.urls || data.sprites || [];

                        if (spriteUrls.length > 0) {
                            localStorage.setItem(`sprites_${boxType}`, JSON.stringify(spriteUrls));
                            console.log(`Loaded ${spriteUrls.length} sprite URLs from Firestore for ${boxType}`);
                        }
                    } else {
                        console.log(`No remote sprites found for ${boxType}`);
                    }
                }
            } catch (e) {
                console.error("Error loading sprites from Firestore:", e);
            }
        }


        // --- PHASER GAME ---
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game-container',
            backgroundColor: 'rgba(0,0,0,0)',
            transparent: true,
            render: {
                transparent: true,
                clearBeforeRender: true
            },
            physics: {
                default: 'matter',
                matter: {
                    gravity: { y: 1 }, // Will be updated by gameConfig
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        let game;
        let crane;
        let currentBox = null;
        let fallingBox = null; // Track the box currently falling
        let boxes = [];
        let isGameActive = false;
        let score = 0;
        let lives = 3; // New Lives System
        let recordLine; // Graphics for record line
        let recordLineLabel; // "Você" label
        let rankingLines = []; // {y, gfx, label, passed}
        let sessionBestY = sessionStorage.getItem('sessionBestY') ? parseFloat(sessionStorage.getItem('sessionBestY')) : null; // Stored best from previous games
        let currentGameMinY = null; // Track best height of CURRENT game
        let craneSpeed = 2;
        const CRANE_Y = -50; // Absolute top (visual offset handled in update)
        let playerName = 'JOG'; // Default player name
        let isSceneReady = false; // Flag to ensure create() has finished
        let instructionHidden = false; // Flag to hide instruction only once
        let gameStartTime = Date.now(); // Track game start time for anti-hack logging
        let godMode = false; // Infinite lives toggle

        // Mascot Variables
        let mascotBody;
        let mascotFace;
        let mascotLever;
        let isMascotVisible = true;
        const MASCOT_SCALE = 0.20; // smaller mascot
        const MASCOT_MARGIN_RIGHT = 24;
        const MASCOT_MARGIN_BOTTOM = -20; // Lowered mascot position (was 12)
        const MASCOT_LEVER_OFFSET_X = 0.95; // slight move left
        const MASCOT_LEVER_OFFSET_Y = 20; // lift arm higher
        const MASCOT_ARM_SCALE = 1.95; // enlarge lever/wing further (increased by 30%)

        // Dynamic Sprite Storage
        let availableSprites = {
            normal: [],
            goal: [],
            goalRect: [],
            ice: [],
            iceRect: []
        };

        let lastMouseClickTs = Date.now();
        let rankingHeights = [];

        // Box Configuration (Data-Driven)
        // Box Configuration (Data-Driven)
        // Box Configuration (Data-Driven)
        let defaultBoxTypes = [
            {
                id: 'normal_square',
                category: 'normal',
                name: 'Normal Quadrada',
                chance: 45,
                textures: ['normal_1', 'normal_2', 'normal_3'],
                width: 143,
                height: 143,
                densityRange: [0.009, 0.011],
                friction: 0.3, // Reduced friction for normal boxes (was 0.5)
                bounce: 0.1,
                variations: 1,
                sizeIncrement: 0
            },
            {
                id: 'normal_rect',
                category: 'normal',
                name: 'Normal Retangular',
                chance: 40,
                textures: ['retangulo_1', 'retangulo_2', 'retangulo_3', 'retangulo_4', 'retangulo_5', 'retangulo_6', 'retangulo_7', 'retangulo_8', 'retangulo_9', 'retangulo_10'],
                width: 172,
                height: 98, // will keep proportion 421x241 via ratio below
                densityRange: [0.009, 0.011],
                friction: 0.3, // Reduced friction for normal boxes (was 0.5)
                bounce: 0.1,
                variations: 1,
                sizeIncrement: 0
            },
            {
                id: 'goal_square',
                category: 'goal',
                name: 'Meta Quadrada',
                chance: 5, // Equalized with Ice (was 10)
                textures: ['goal_square'],
                width: 143,
                height: 143,
                densityRange: [0.06, 0.08],
                friction: 0.9,
                bounce: 0.01,
                variations: 1,
                sizeIncrement: 0
            },
            {
                id: 'goal_rect',
                category: 'goalRect',
                name: 'Meta Retangular',
                chance: 5, // Equalized with Ice (was 10)
                textures: ['goal_rect'],
                width: 172,
                height: 98, // proportional to 421x241
                densityRange: [0.06, 0.08],
                friction: 0.9,
                bounce: 0.01,
                variations: 1,
                sizeIncrement: 0
            },
            {
                id: 'ice_square',
                category: 'ice',
                name: 'Gelo Quadrada',
                chance: 3, // Reduced chance (was 5)
                textures: ['ice_1', 'ice_2', 'ice_3'],
                width: 143,
                height: 143,
                densityRange: [0.11, 0.13], // heavier to fall faster
                friction: 0.16, // less sliding
                bounce: 0.02,
                variations: 1,
                sizeIncrement: 0
            },
            {
                id: 'ice_rect',
                category: 'iceRect',
                name: 'Gelo Retangular',
                chance: 3, // Reduced chance (was 5)
                textures: ['ice_rect_1', 'ice_rect_2', 'ice_rect_3'],
                width: 172,
                height: 98,
                densityRange: [0.11, 0.13], // heavier to fall faster
                friction: 0.16, // less sliding
                bounce: 0.02,
                variations: 1,
                sizeIncrement: 0
            },
        ];

        // Load box config from local storage or use default
        // let boxTypes = JSON.parse(localStorage.getItem('boxTypes')) || JSON.parse(JSON.stringify(defaultBoxTypes));
        let boxTypes = JSON.parse(JSON.stringify(defaultBoxTypes));

        // DATA MIGRATION: Ensure 'textures' array exists for old saves
        boxTypes.forEach(type => {
            if (!type.textures || type.textures.length === 0) {
                const def = defaultBoxTypes.find(t => t.id === type.id);
                if (def) {
                    type.textures = [...def.textures];
                } else {
                    type.textures = [type.texture || 'box'];
                }
            }
            if (!type.category) {
                type.category = type.id && type.id.includes('goal') ? 'goal' : 'normal';
            }
            if (!type.densityRange) {
                const baseDensity = type.density || 0.01;
                type.densityRange = [baseDensity, baseDensity];
            }
        });

        // Background palettes: calm pastels -> mid vibrance -> hard/red
        const backgroundPalettes = [
            { id: 'calm', top: '#cfe9e3', mid: '#a2d7e6', bottom: '#8bb6d9' },       // gentle teal/blue
            { id: 'mid', top: '#c9d4ff', mid: '#f1c6ff', bottom: '#ffcad4' },        // dreamy lilac/peach
            { id: 'hard', top: '#ffcba4', mid: '#ff9a9e', bottom: '#ff5f6d' }        // vibrant warm/red
        ];

        let ropeGraphics;
        let swingTime = 0;
        let buttonSprite;
        let background; // Gradient background
        let currentBgPhase = -1; // Track which gradient phase is active
        let currentBgPalette = backgroundPalettes[0];
        let prevBgPalette = backgroundPalettes[0];
        let bgTransitionStart = null;
        const BG_TRANSITION_MS = 5000;

        // --- AUDIO SYSTEM ---
        let musicBg;
        let soundEnabled = true;

        function playSound(scene, key, config = {}) {
            if (!soundEnabled) return;
            try {
                scene.sound.play(key, config);
            } catch (e) {
                // console.warn('Audio play failed:', e);
            }
        }

        function initAudio(scene) {
            if (!musicBg) {
                try {
                    musicBg = scene.sound.add('music_bg', { loop: true, volume: 0.25 });
                    if (isGameActive) {
                        musicBg.play();
                    }
                } catch (e) {
                    console.warn('Music init failed:', e);
                }
            }
        }

        function blendHex(c1, c2, t) {
            const n1 = parseInt(c1.replace('#', ''), 16);
            const n2 = parseInt(c2.replace('#', ''), 16);
            const r1 = (n1 >> 16) & 255, g1 = (n1 >> 8) & 255, b1 = n1 & 255;
            const r2 = (n2 >> 16) & 255, g2 = (n2 >> 8) & 255, b2 = n2 & 255;
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function applyDifficultyScaling() {
            // Score is now number of boxes (1, 2, 3...).
            // Linear scaling: 0.1 speed per box.
            // 10 boxes = +1 speed. 20 boxes = +2 speed (max).
            const speedIncrease = score * gameConfig.difficultyMultiplier;

            // Cap the additional speed to keep the crane manageable.
            const maxAdditionalSpeed = 2; // max extra beyond baseSpeed
            const additionalSpeed = Math.min(speedIncrease, maxAdditionalSpeed);
            craneSpeed = gameConfig.baseSpeed + additionalSpeed;
        }

        // Choose palette phase by score (acts as difficulty stage)
        function getDifficultyPhaseByScore(currentScore) {
            if (currentScore >= 25) return 2; // hardest - red
            if (currentScore >= 10) return 1; // mid - lilac/peach
            return 0; // calm - teal
        }

        function lerpPalette(a, b, t) {
            return {
                top: blendHex(a.top, b.top, t),
                mid: blendHex(a.mid, b.mid, t),
                bottom: blendHex(a.bottom, b.bottom, t)
            };
        }

        // Generate/update gradient background for current phase
        function updateBackgroundGradient(scene, force = false) {
            if (!scene || !backgroundPalettes.length) return;
            const phase = getDifficultyPhaseByScore(score);
            if (!force && phase === currentBgPhase && !bgTransitionStart) return;

            const targetPalette = backgroundPalettes[phase] || backgroundPalettes[0];
            if (phase !== currentBgPhase || force) {
                prevBgPalette = currentBgPalette;
                currentBgPhase = phase;
                bgTransitionStart = Date.now();
            }

            let t = 1;
            if (bgTransitionStart) {
                t = Math.min(1, (Date.now() - bgTransitionStart) / BG_TRANSITION_MS);
                if (t >= 1) bgTransitionStart = null;
            }
            currentBgPalette = lerpPalette(prevBgPalette, targetPalette, t);
            const palette = currentBgPalette;
            const { width, height } = scene.scale;

            // Update DOM gradient fallback (ensures visible background even if Phaser texture fails)
            const domBg = document.getElementById('bg-gradient-layer');
            if (domBg) {
                domBg.style.background = `linear-gradient(180deg, ${palette.top} 0%, ${palette.mid} 50%, ${palette.bottom} 100%)`;
            }
            document.documentElement.style.setProperty('--bg-grad', `linear-gradient(180deg, ${palette.top} 0%, ${palette.mid} 50%, ${palette.bottom} 100%)`);

            // Create gradient texture via HTML canvas (works in WebGL and Canvas)
            const canvas = document.createElement('canvas');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            const grd = ctx.createLinearGradient(0, 0, 0, height);
            const midTop = blendHex(palette.top, palette.mid, 0.5);
            const midBottom = blendHex(palette.mid, palette.bottom, 0.5);
            grd.addColorStop(0, palette.top);
            grd.addColorStop(0.33, midTop);
            grd.addColorStop(0.66, midBottom);
            grd.addColorStop(1, palette.bottom);
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, width, height);

            if (scene.textures.exists('dynamic_bg')) {
                scene.textures.remove('dynamic_bg');
            }
            scene.textures.addCanvas('dynamic_bg', canvas);

            if (background) {
                background.setTexture('dynamic_bg');
                background.setDisplaySize(width, height);
                background.setPosition(width / 2, height / 2);
            } else {
                background = scene.add.image(width / 2, height / 2, 'dynamic_bg');
                background.setScrollFactor(0);
                background.setDepth(-100);
            }

            currentBgPhase = phase;
        }

        function updateScoreUI() {
            const scoreText = document.getElementById('score-display');
            if (scoreText) {
                scoreText.innerText = `SCORE: ${score}`;

                if (score > 0 && score % 10 === 0) {
                    scoreText.classList.add('score-milestone');
                    setTimeout(() => {
                        scoreText.classList.remove('score-milestone');
                    }, 500);
                }
            }
            applyDifficultyScaling();

            // Refresh background gradient when score crosses phase thresholds
            const scene = (game && game.scene && game.scene.scenes && game.scene.scenes[0]) ? game.scene.scenes[0] : null;
            updateBackgroundGradient(scene);
        }

        function initGame() {
            if (game) return;
            game = new Phaser.Game(config);
            // Expose to global scope for debug sidebar
            window.game = game;
            window.gameConfig = gameConfig;
            window.craneSpeed = craneSpeed;
            window.score = score;
            window.boxes = boxes;
            window.defaultBoxTypes = defaultBoxTypes;
        }

        function preload() {
            this.load.crossOrigin = 'anonymous'; // Fix CORS for Firebase Storage
            const graphics = this.make.graphics({ x: 0, y: 0, add: false });

            // Load ranking heights (optional, from localStorage)
            try {
                rankingHeights = JSON.parse(localStorage.getItem('rankingBestHeights') || '[]')
                    .filter(v => typeof v === 'number');
            } catch (e) {
                rankingHeights = new Array(5).fill(0);
                localStorage.setItem('rankingBestHeights', JSON.stringify(rankingHeights));
            }
            if (rankingHeights.length === 0) {
                rankingHeights = new Array(5).fill(0); // default placeholders
                localStorage.setItem('rankingBestHeights', JSON.stringify(rankingHeights));
            }

            // God button listener (set up once DOM is ready)
            const godBtn = document.getElementById('god-btn');
            if (godBtn && !godBtn.dataset.bound) {
                godBtn.dataset.bound = '1';
                godBtn.addEventListener('click', () => {
                    godMode = !godMode;
                    godBtn.textContent = godMode ? 'GOD ON' : 'GOD';
                    if (godMode) {
                        godBtn.style.background = '#00aa55';
                        godBtn.style.color = '#000';
                        godBtn.style.borderColor = '#fff';
                        godBtn.style.boxShadow = '4px 4px 0px #003322';
                    } else {
                        godBtn.style.background = '#fff';
                        godBtn.style.color = '#000';
                        godBtn.style.borderColor = '#fff';
                        godBtn.style.boxShadow = '4px 4px 0px #000';
                    }
                });
            }

            // Box Textures (Local Assets - Blind Load 1-20)
            for (let i = 1; i <= 20; i++) {
                this.load.image(`normal_${i}`, `assets/sprites/normal/${i}.png`);
            }
            const goalSprites = ['goal_square', 'goal_rect'];
            goalSprites.forEach(key => {
                this.load.image(key, `assets/sprites/heavy/${key}.png`);
            });

            for (let i = 1; i <= 10; i++) {
                this.load.image(`retangulo_${i}`, `assets/sprites/retangulo/${i}.png`);
            }

            for (let i = 1; i <= 10; i++) {
                this.load.image(`ice_${i}`, `assets/sprites/ice/${i}.png`);
                this.load.image(`ice_rect_${i}`, `assets/sprites/ice_retangulo/${i}.png`);
            }

            // --- AUDIO ASSETS ---
            this.load.audio('music_bg', 'assets/audio/music_bg.mp3');
            this.load.audio('sfx_gameover', 'assets/audio/game over.ogg');
            this.load.audio('sfx_land', 'assets/audio/sfx_land.mp3.ogg');
            this.load.audio('sfx_ice', 'assets/audio/sfx_ice.ogg');
            this.load.audio('sfx_iron', 'assets/audio/sfx_iron.ogg');
            this.load.audio('sfx_ui_click', 'assets/audio/sfx_ui_btn.ogg');
            this.load.audio('sfx_heart_lost', 'assets/audio/heart_lost.ogg');
            this.load.audio('sfx_score_pass', 'assets/audio/score_pass.ogg');

            // 2. Crane (Simple Gray)
            graphics.clear();
            graphics.fillStyle(0x888888);
            graphics.fillRect(0, 0, 20, 100); // Main vertical pole
            graphics.fillStyle(0x555555);
            graphics.fillRect(-10, 80, 40, 20); // Bottom weight
            graphics.generateTexture('crane', 40, 100);

            // 4. Platform (Full Width & Height)
            graphics.clear();
            graphics.fillStyle(0x00ffff); // Primary color
            graphics.fillRect(0, 0, 2000, 100); // Taller to cover bottom
            graphics.lineStyle(4, 0x00ffff); // Cyan border
            graphics.strokeRect(0, 0, 2000, 100);
            graphics.generateTexture('platform', 2000, 100);

            // 5. Owl (Happy) - Improved
            graphics.clear();
            // Body
            graphics.fillStyle(0x8B4513);
            graphics.fillRoundedRect(10, 10, 60, 80, 20);
            // Ears
            graphics.beginPath();
            graphics.moveTo(10, 10); graphics.lineTo(0, -10); graphics.lineTo(30, 10);
            graphics.moveTo(70, 10); graphics.lineTo(80, -10); graphics.lineTo(50, 10);
            graphics.fillPath();
            // Belly
            graphics.fillStyle(0xD2B48C);
            graphics.fillEllipse(40, 60, 25, 30);
            // Eyes (Big & Cute)
            graphics.fillStyle(0xFFFFFF);
            graphics.fillCircle(25, 35, 12);
            graphics.fillCircle(55, 35, 12);
            graphics.fillStyle(0x000000);
            graphics.fillCircle(25, 35, 5);
            graphics.fillCircle(55, 35, 5);
            graphics.fillStyle(0xFFFFFF); // Shine
            graphics.fillCircle(27, 33, 2);
            graphics.fillCircle(57, 33, 2);
            // Wing Texture Removed

            // 6. Owl (Fearful) - Improved
            graphics.clear();
            // Body
            graphics.fillStyle(0x8B4513);
            // Wing
            graphics.clear();
            graphics.fillStyle(0x654321);
            graphics.fillEllipse(20, 12, 20, 12);
            graphics.generateTexture('wing', 40, 25);

            // 7. Heart (Lives) - Pixel Art Style
            graphics.clear();
            graphics.fillStyle(0xff0000);
            // Simple pixel heart 32x32
            // Top bumps
            graphics.fillRect(4, 4, 10, 8);
            graphics.fillRect(18, 4, 10, 8);
            // Middle
            graphics.fillRect(2, 12, 28, 8);
            // Bottom taper
            graphics.fillRect(6, 20, 20, 6);
            graphics.fillRect(10, 26, 12, 4);
            graphics.fillRect(14, 30, 4, 2);

            graphics.generateTexture('heart', 32, 32);

            // 8. Spark (Perfect Drop)
            graphics.clear();
            graphics.fillStyle(0xffff00);
            graphics.fillCircle(4, 4, 4);
            graphics.generateTexture('spark', 8, 8);

            // Background Texture (Digital Circuit)
            // Background Texture (Digital Circuit)
            this.load.image('bg_digital', 'assets/bg_digital.png');

            graphics.destroy();

            // --- MASCOT ASSETS (Real Sprites) ---
            this.load.image('mascot_normal', 'assets/mascot/normal.png');
            this.load.image('mascot_worried', 'assets/mascot/woried_1.png');
            this.load.image('mascot_worried2', 'assets/mascot/woried_2.png');
            this.load.image('mascot_sad', 'assets/mascot/sad.png');
            this.load.image('lever_rest', 'assets/mascot/alavanca normal.png');
            this.load.image('lever_pull', 'assets/mascot/alavanca puxada.png');
            // Load custom uploaded sprites from localStorage
            // Load custom uploaded sprites from localStorage using Phaser Loader
            // DISABLED TEMPORARILY TO FIX CORS/GAME BUGS
            /*
            boxTypes.forEach(type => {
                const customSprites = JSON.parse(localStorage.getItem(`sprites_${type.id}`) || '[]');
                customSprites.forEach((url, idx) => {
                    const textureKey = `${type.id}_custom_${idx}`;
                    console.log(`Preloading custom sprite: ${textureKey}`);
                    this.load.image(textureKey, url);
                });
            });
            */
        }

        function create() {
            const { width, height } = this.scale;

            // DETECT AVAILABLE SPRITES
            // Check which textures actually loaded successfully
            availableSprites.normal = [];
            availableSprites.normalRect = []; // Added normalRect
            availableSprites.goal = [];

            for (let i = 1; i <= 20; i++) {
                if (this.textures.exists(`normal_${i}`)) {
                    availableSprites.normal.push(`normal_${i}`);
                }
            }
            for (let i = 1; i <= 10; i++) {
                if (this.textures.exists(`retangulo_${i}`)) {
                    availableSprites.normalRect.push(`retangulo_${i}`);
                }
            }

            const goalTextureKeys = ['goal_square', 'goal_rect'];
            goalTextureKeys.forEach(key => {
                if (this.textures.exists(key)) {
                    availableSprites.goal.push(key);
                }
            });

            availableSprites.goalRect = [];
            if (this.textures.exists('goal_rect')) {
                availableSprites.goalRect.push('goal_rect');
            }

            availableSprites.ice = [];
            availableSprites.iceRect = [];
            for (let i = 1; i <= 10; i++) {
                const iceKey = `ice_${i}`;
                if (this.textures.exists(iceKey)) {
                    availableSprites.ice.push(iceKey);
                }
                const iceRectKey = `ice_rect_${i}`;
                if (this.textures.exists(iceRectKey)) {
                    availableSprites.iceRect.push(iceRectKey);
                }
            }
            console.log("Available Sprites Detected:", availableSprites);

            // Fallback if no sprites loaded (prevent crash)
            if (availableSprites.normal.length === 0) {
                // Create a fallback texture if none exist
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0xFFFFFF);
                graphics.fillRect(0, 0, 128, 128);
                graphics.generateTexture('normal_fallback', 128, 128);
                availableSprites.normal.push('normal_fallback');
            }
            if (availableSprites.normalRect.length === 0) {
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0xFFFFFF);
                graphics.fillRect(0, 0, 172, 98);
                graphics.generateTexture('normal_rect_fallback', 172, 98);
                availableSprites.normalRect.push('normal_rect_fallback');
            }
            if (availableSprites.goal.length === 0) {
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0xCCCCCC);
                graphics.fillRect(0, 0, 143, 82);
                graphics.generateTexture('goal_fallback', 143, 82);
                availableSprites.goal.push('goal_fallback');
            }
            if (availableSprites.ice.length === 0) {
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0x99d9ff);
                graphics.fillRect(0, 0, 128, 128);
                graphics.generateTexture('ice_fallback', 128, 128);
                availableSprites.ice.push('ice_fallback');
            }
            if (availableSprites.iceRect.length === 0) {
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0x99d9ff);
                graphics.fillRect(0, 0, 172, 98);
                graphics.generateTexture('ice_rect_fallback', 172, 98);
                availableSprites.iceRect.push('ice_rect_fallback');
            }

            // ... (rest of create) ...
            // ... (skip to spawnBox) ...
            // Select Texture - Map new types to existing sprite categories

            // ... (skip to createPerfectDropEffect) ...


            // Matter.js World Bounds - Completely disabled to allow boxes to fall off screen
            // No bounds at all = boxes can go anywhere
            // this.matter.world.setBounds() - commented out intentionally
            this.matter.world.setGravity(0, gameConfig.gravity);

            // Background (dynamic gradient, scrolls softly with camera)
            updateBackgroundGradient(this, true);
            this.cameras.main.setBackgroundColor('rgba(0,0,0,0)');

            // Platform (visible base)
            const platform = this.matter.add.image(width / 2, height - 50, 'platform', null, { isStatic: true });
            platform.setDisplaySize(width, 100);
            platform.setDepth(5);

            // Crane
            crane = this.add.image(width / 2, CRANE_Y, 'crane');
            crane.setDepth(10);
            crane.setVisible(false); // Hide the crane pole, keep only rope

            ropeGraphics = this.add.graphics();
            ropeGraphics.setDepth(-1);

            // Mark scene as ready
            isSceneReady = true;
            console.log('Scene Create Complete. isSceneReady = true');
            // Owl Frame Removed

            // Update Restart Button Text
            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) restartBtn.innerHTML = 'TENTAR DE NOVO <span class="shortcut-key">[ENTER]</span>';

            // Input
            this.input.on('pointerdown', () => {
                // console.log('Click detected. isGameActive:', isGameActive, 'currentBox:', !!currentBox, 'fallingBox:', !!fallingBox);
                lastMouseClickTs = Date.now();

                // Hide instruction on first interaction
                if (!instructionHidden) {
                    const instruction = document.getElementById('instructionText');
                    if (instruction) {
                        instruction.style.display = 'none';
                        instructionHidden = true;
                    }
                }

                if (isGameActive && currentBox && !fallingBox) {
                    dropBox(this);
                    // Wing animation removed
                } else {
                    // console.log('Click ignored. Conditions not met.');
                }
            });

            // Keyboard Shortcuts
            this.input.keyboard.on('keydown-SPACE', () => {
                // Hide instruction on first interaction
                if (!instructionHidden) {
                    const instruction = document.getElementById('instructionText');
                    if (instruction) {
                        instruction.style.display = 'none';
                        instructionHidden = true;
                    }
                }

                if (isGameActive && currentBox && !fallingBox) {
                    dropBox(this);
                }
            });

            this.input.keyboard.on('keydown-ENTER', () => {
                // console.log('ENTER pressed');
                const gameOverScreen = document.getElementById('game-over-screen');
                const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');

                // console.log('State:', { isGameActive, gameOverVisible });

                if (!isGameActive && gameOverVisible) {
                    // console.log('Action: Start Game (from Game Over)');
                    startGame();
                }
            });

            this.input.keyboard.on('keydown-ENTER', () => {
                const gameOverScreen = document.getElementById('game-over-screen');
                const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');
                if (!isGameActive && gameOverVisible) {
                    const restart = document.getElementById('restart-btn');
                    if (restart) restart.click();
                }
            });
            // Collision (Freeze Logic & Game Over)
            this.matter.world.on('collisionstart', (event) => {
                event.pairs.forEach(pair => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    // Check for Game Over condition: Box hitting the platform when it's not the first box
                    if (bodyA.gameObject === platform || bodyB.gameObject === platform) {
                        const otherBody = bodyA.gameObject === platform ? bodyB : bodyA;
                        if (otherBody && otherBody.gameObject && boxes.includes(otherBody.gameObject)) {
                            // If it's NOT the first box (index 0), then it fell on the floor -> Lose Life
                            if (boxes.indexOf(otherBody.gameObject) > 0) {
                                handleLifeLoss(this, otherBody.gameObject);
                                return; // Stop processing this collision
                            }
                        }
                    }

                    [bodyA, bodyB].forEach(body => {
                        if (body.gameObject && boxes.includes(body.gameObject) && !body.isStatic) {
                            // Heavy/Goal Box Impact Animation
                            if ((body.gameObject.boxCategory === 'goal' || body.gameObject.boxCategory === 'goalRect') && !body.gameObject.hasImpacted) {
                                body.gameObject.hasImpacted = true;
                                // Shake camera: duration 200ms, intensity 0.005
                                this.cameras.main.shake(200, 0.005);
                            }
                            // Play sound immediately on collision
                            if (!body.gameObject.hasPlayedSound) {
                                body.gameObject.hasPlayedSound = true;
                                const cat = body.gameObject.boxCategory;
                                if (cat === 'ice' || cat === 'iceRect') {
                                    playSound(this, 'sfx_ice', { volume: 0.8 });
                                } else if (cat === 'goal' || cat === 'goalRect') {
                                    playSound(this, 'sfx_iron', { volume: 0.8 });
                                } else {
                                    playSound(this, 'sfx_land', { volume: 0.6, detune: Phaser.Math.Between(-200, 200) });
                                }
                            }

                            // Freeze box after collision (prevent bouncing/sliding)
                            // Body starts freezing after 1 second of low velocity
                            if (!body.gameObject.isFreezing) {
                                body.gameObject.isFreezing = true;
                                this.time.delayedCall(1000, () => {
                                    if (body.gameObject && body.gameObject.body) {
                                        if (body.speed < 0.5 && Math.abs(body.angularVelocity) < 0.05) {
                                            body.gameObject.setStatic(true);
                                            body.gameObject.setRotation(0);
                                            // Align to grid (optional, but helps stability)
                                            // body.gameObject.x = Math.round(body.gameObject.x); 

                                            if (!body.gameObject.hasScored) {
                                                body.gameObject.hasScored = true;
                                                const landedBox = body.gameObject;

                                                // Track current game best height (min Y)
                                                if (currentGameMinY === null || landedBox.y < currentGameMinY) {
                                                    currentGameMinY = landedBox.y;
                                                }

                                                // SCORE IS NOW 1 POINT PER BOX
                                                score += 1;
                                                updateScoreUI();

                                                // Perfect Drop Logic REMOVED as per request
                                            }
                                        } else {
                                            // Retry if still moving
                                            if (!body.gameObject.setStatic && body.gameObject.isFreezing) {
                                                this.time.delayedCall(500, () => {
                                                    if (body.gameObject && body.gameObject.body) {
                                                        body.gameObject.isFreezing = false; // Allow re-evaluation
                                                    }
                                                });
                                            } else {
                                                body.gameObject.isFreezing = false;
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    });
                });
            });
            // Create ends
            createMascot(this);

            // Initialize Record Line
            recordLine = this.add.graphics();
            updateRecordLine(this);

            isSceneReady = true;

            // Hide loading screen
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }

            this.scene.pause();
        }

        function update(time, delta) {
            if (!isSceneReady) return;
            updateMascotState(this);
            updateRecordLine(this);
            if (!isGameActive) return;

            const { width, height } = this.scale;

            // Scroll Backgrounds
            // Move background texture based on camera scroll (Parallax effect)
            if (background) {
                background.tilePositionY = this.cameras.main.scrollY * 0.5;
            }

            // Hide Instruction (respect flag from user interaction)
            const instructionText = document.getElementById('instructionText');
            if (instructionText && !instructionHidden) {
                instructionText.style.display = this.cameras.main.scrollY === 0 ? 'block' : 'none';
            } else if (instructionText && instructionHidden) {
                instructionText.style.display = 'none';
            }

            // 1. Game Logic: Spawn new box if falling box is done
            if (fallingBox) {
                // If falling box is static (landed)
                if (fallingBox.body && fallingBox.body.isStatic) {
                    fallingBox = null;
                    spawnBox(this);
                }
                // Removed the out of bounds check here, as platform collision handles it now.
            }

            // Check if FIRST box (index 0) fell off screen horizontally
            if (boxes.length > 0 && boxes[0]) {
                const firstBox = boxes[0];
                const screenCenterX = width / 2;
                const maxOffset = width * 0.6; // If first box is more than 60% of screen width away from center, Game Over

                if (Math.abs(firstBox.x - screenCenterX) > maxOffset) {
                    // console.log('First box fell off screen horizontally! Game Over.');
                    handleLifeLoss(this, firstBox);
                    return;
                }
            }

            // 2. Calculate Tower Stats (Height & Stability)
            let highestStaticY = height - 100; // Start at platform level
            let totalDeviation = 0;
            let staticBoxCount = 0;

            boxes.forEach(box => {
                // Ignore the current box being carried by the crane!
                if (box !== currentBox) {
                    // Check for fall (Game Over)
                    // Fix: Only check if the box is NOT static (i.e., it's falling)
                    // Static boxes are part of the stack and are allowed to go off-screen
                    if (!box.body.isStatic && box.y > this.cameras.main.scrollY + height + 200) {
                        // Only if it's not the first box (which is on the platform)
                        // But wait, the platform is at height-50.
                        // If a box falls off the stack, it will go down.
                        // If it's index > 0 and y > height - 50 + buffer, it missed the stack.
                        if (boxes.indexOf(box) > 0) {
                            // console.log('Box fell off stack!');
                            handleLifeLoss(this, box);
                            return;
                        }
                    }

                    if (box.body && box.body.isStatic) {
                        if (box.y < highestStaticY) highestStaticY = box.y;
                        totalDeviation += Math.abs(box.x - width / 2);
                        staticBoxCount++;
                    }
                }
            });

            // Update Height UI
            const heightText = document.getElementById('height-display');
            if (heightText) heightText.innerText = 'ALTURA: ' + towerHeight + 'm';

            // 3. Camera Follow (Lazy Follow)
            if (!fallingBox) {
                // Dynamic gap based on screen height to ensure top box is always visible
                // Target position: Top of stack should be around 80% down the screen (further from crane)
                const minGap = height * 0.8;
                const currentCraneY = this.cameras.main.scrollY + 50;

                // If stack is too close to crane (highestStaticY is smaller than craneY + gap)
                if (highestStaticY < currentCraneY + minGap) {
                    const targetCamY = highestStaticY - minGap - 50;
                    this.cameras.main.scrollY += (targetCamY - this.cameras.main.scrollY) * 0.05;
                }
            }

            // 4. Crane Position (Always above camera view)
            // Crane stays at fixed relative position to camera top, or follows tower?
            // User asked for "topo zero da tela".
            // So crane.y should be camera.scrollY
            crane.y = this.cameras.main.scrollY;

            // 5. Rope & Swing
            ropeGraphics.clear();
            if (currentBox && currentBox.isCarried) {
                // Calculate Speed Factor based on Box Density (Weight)
                // Base density is around 0.01 (normal). Ice is 0.04-0.05.
                // Heavier boxes should swing SLOWER.
                // Factor = Base / Current. If Current > Base, Factor < 1 (Slower).
                const baseDensity = 0.01;
                const currentDensity = currentBox.body ? currentBox.body.density : baseDensity;

                // Clamp density to avoid extreme values
                const effectiveDensity = Math.max(baseDensity, currentDensity);

                // Speed Multiplier: 
                // Normal (0.01) -> 1.0
                // Ice (0.05) -> 0.2 (Too slow? Let's tune)
                // Let's use a gentler curve: 1 / sqrt(density ratio)
                const densityRatio = effectiveDensity / baseDensity;
                const speedFactor = 1 / Math.sqrt(densityRatio);

                // Apply speed factor to swing time
                const adjustedSpeedFactor = Math.max(speedFactor, 0.55); // clamp minimum so heavy boxes don't crawl
                swingTime += delta * (craneSpeed * adjustedSpeedFactor * 0.0005);

                const ropeLength = 230; // Slightly shorter to tighten attach
                const maxSwingAngle = 0.6; // Reduced from 1.0 to be less wide
                const angle = Math.sin(swingTime) * maxSwingAngle;

                const ropeEndX = crane.x + Math.sin(angle) * ropeLength;
                const ropeEndY = crane.y + Math.cos(angle) * ropeLength;

                const halfH = currentBox.displayHeight ? currentBox.displayHeight / 2 : 64;
                const boxX = ropeEndX;
                const boxY = ropeEndY + halfH;

                currentBox.setPosition(boxX, boxY);
                currentBox.setRotation(0); // NO ROTATION on crane

                // Analytical Velocity Calculation (Derivative)
                // Theta = sin(swingTime) * maxSwingAngle
                // dTheta/dt = cos(swingTime) * maxSwingAngle * speedFactor
                // Note: speedFactor here refers to the angular speed multiplier (craneSpeed * speedFactor * 0.0005)
                const angularSpeed = craneSpeed * adjustedSpeedFactor * 0.0005;
                const dThetaDt = Math.cos(swingTime) * maxSwingAngle * angularSpeed; // rad/ms

                // Vx = L * cos(Theta) * dTheta/dt
                // Vy = -L * sin(Theta) * dTheta/dt
                // Multiply by 16.66 to convert px/ms to px/frame (Matter.js units)
                const frameTime = 16.66;
                currentBox.swingVelX = (ropeLength * Math.cos(angle) * dThetaDt) * frameTime;
                currentBox.swingVelY = (ropeLength * -Math.sin(angle) * dThetaDt) * frameTime;

                ropeGraphics.lineStyle(4, 0xffffff);
                ropeGraphics.beginPath();
                ropeGraphics.moveTo(crane.x, crane.y); // Start exactly at top
                ropeGraphics.lineTo(ropeEndX, ropeEndY);
                ropeGraphics.strokePath();
            }
        }
        function spawnBox(scene) {
            // console.log('spawnBox called. isGameActive:', isGameActive, 'currentBox:', currentBox);
            if (!isGameActive) return;
            if (currentBox) return;

            isDropping = false; // Reset drop flag for the new box

            const { width } = scene.scale;

            // Select Box Type based on Chance
            // First box always Normal if possible, or just random?
            // User previously wanted first box not to be goal/heavy.
            // Let's filter for 'normal' type for first box if it exists.

            let selectedType;
            if (boxes.length === 0) {
                // First box: prefer normal_square or normal_rect
                selectedType = boxTypes.find(t => t.id.includes('normal')) || boxTypes[0];
            }
            // FORCE NORMAL BOXES FOR THE FIRST FEW DROPS (e.g. first 3 boxes)
            const isEarlyGame = score < 3;

            let possibleTypes = boxTypes; // Use boxTypes as the base list

            // Filter available types based on game state
            let availableTypes = possibleTypes.filter(type => {
                // Ice boxes only appear after score >= 10
                if (type.category.includes('ice') && score < 10) return false;
                // If early game, only allow 'normal' or 'normalRect' types
                if (isEarlyGame && !(type.category === 'normal' || type.category === 'normalRect')) return false;
                return true;
            });

            // Fallback if filter leaves nothing (shouldn't happen if config is good)
            if (availableTypes.length === 0) availableTypes = possibleTypes;

            // Weighted Random Selection
            const totalChance = availableTypes.reduce((sum, t) => sum + (t.chance || 1), 0);
            let random = Math.random() * totalChance;
            selectedType = availableTypes[0]; // Initialize with first available type as fallback

            for (const t of availableTypes) {
                random -= (t.chance || 1);
                if (random <= 0) {
                    selectedType = t;
                    break;
                }
            }

            // Select Sprite Texture
            const spriteCategory = selectedType.category;
            let spriteList = availableSprites[spriteCategory];

            // Fallback logic
            if (!spriteList || spriteList.length === 0) {
                // Try normal if specific category missing
                spriteList = availableSprites.normal;
            }

            // Ensure we don't pick a goal/heavy sprite if we really want normal
            // (Double check in case availableSprites has mixed content, though it shouldn't)
            if (spriteCategory === 'normal' || spriteCategory === 'normalRect') {
                const isRect = selectedType.id && selectedType.id.includes('rect');
                if (isRect && availableSprites.normalRect.length > 0) {
                    spriteList = availableSprites.normalRect;
                } else {
                    // remove any goal/heavy textures if leaked
                    spriteList = spriteList.filter(key => !key.includes('goal') && !key.includes('heavy'));
                }
            }

            if (!spriteList || spriteList.length === 0) {
                console.error('No sprites available for type:', selectedType.id);
                return;
            }

            const textureKey = Phaser.Utils.Array.GetRandom(spriteList);
            // console.log(`Spawning box with texture: ${textureKey}`);

            // Spawn at crane position
            const box = scene.matter.add.image(width / 2, crane.y + 250, textureKey);
            box.setDepth(5); // keep rope behind box

            // Apply Physics Properties
            // DYNAMIC PHYSICS: Match body size to BOX TYPE dimensions (User Request)
            // Calculate size with variation
            const variations = selectedType.variations || 1;
            const increment = selectedType.sizeIncrement || 0;
            const randomVariation = Phaser.Math.Between(0, variations - 1);
            const sizeOffset = randomVariation * increment;

            const finalWidth = selectedType.width + sizeOffset;
            let finalHeight = selectedType.height + sizeOffset;
            // Keep rect proportion close to 421x241 when flagged by height preset 82
            if (selectedType.id.includes('rect')) {
                const ratio = 241 / 421;
                finalHeight = Math.round(finalWidth * ratio);
            }

            box.setDisplaySize(finalWidth, finalHeight);
            // Physics Fix: Slightly smaller body to prevent edge snagging/floating
            // and add small chamfer for smoother stacking
            box.setRectangle(finalWidth - 4, finalHeight - 4, { chamfer: { radius: 2 } });

            // const texture = scene.textures.get(textureKey);
            // const frame = texture.get();
            // const texWidth = frame.width;
            // const texHeight = frame.height;
            // box.setRectangle(texWidth, texHeight);
            const density = selectedType.densityRange
                ? Phaser.Math.FloatBetween(selectedType.densityRange[0], selectedType.densityRange[1])
                : (selectedType.density || 0.01);
            box.setDensity(density);
            box.setFriction(selectedType.friction);
            box.setBounce(selectedType.bounce);
            // Ajustes de fricção por categoria
            if (spriteCategory === 'goal' || spriteCategory === 'goalRect') {
                box.setFriction(Math.max(selectedType.friction, 0.95));
                box.setFrictionStatic(1.4);
                box.setFrictionAir(0.0005);
                box.setBounce(0);
            } else if (spriteCategory === 'ice' || spriteCategory === 'iceRect') {
                // gelo desliza mais: fricção baixa, mas aumenta conforme inclinação (implícito na física)
                box.setFriction(selectedType.friction);
                box.setFrictionStatic(0.1);
                box.setFrictionAir(0.0002);
            }

            box.boxTypeId = selectedType.id; // Store type ID for reference
            box.boxCategory = spriteCategory;

            box.setIgnoreGravity(true); // Ignore gravity while carried

            box.isCarried = true;
            box.swingVelX = 0;
            box.swingVelY = 0;

            currentBox = box;
            boxes.push(box);
        }

        function dropBox(scene) {
            if (!currentBox || isDropping) return;

            isDropping = true;
            triggerLever(scene);
            // playSound(scene, 'sfx_drop', { volume: 0.8 }); // Asset missing

            // Anti-Hack Logging
            const currentAngle = currentBox.rotation;
            // swingTime is the argument to Math.sin() for the swing
            // We log it to see if the user always drops at the exact same phase (bot behavior)
            logEvent('DROP_BOX', {
                x: crane.x,
                y: crane.y,
                angle: currentAngle,
                swingTime: swingTime,
                swingPhase: swingTime % (Math.PI * 2), // Normalize phase
                clickDelta: Date.now() - lastMouseClickTs
            });

            currentBox.isCarried = false;
            currentBox.setIgnoreGravity(false);

            // Reset velocity to zero before applying swing velocity to prevent physics bugs
            currentBox.setVelocity(0, 0);
            currentBox.setAngularVelocity(0);

            // Apply calculated analytical velocity
            currentBox.setVelocity(currentBox.swingVelX, currentBox.swingVelY);

            fallingBox = currentBox;
            currentBox = null;

            // Spawn next box after delay
            scene.time.delayedCall(1000, () => {
                if (isGameActive) spawnBox(scene);
            });
        }

        function positionMascot(width, height) {
            if (!mascotBody) return;
            const x = width - MASCOT_MARGIN_RIGHT;
            const y = height - MASCOT_MARGIN_BOTTOM;
            mascotBody.setOrigin(1, 1).setScale(MASCOT_SCALE).setPosition(x, y);
            if (mascotLever) {
                mascotLever.setOrigin(1, 1).setScale(MASCOT_SCALE * MASCOT_ARM_SCALE);
                const leverX = x - (mascotBody.displayWidth * MASCOT_LEVER_OFFSET_X);
                mascotLever.setPosition(leverX, y + MASCOT_LEVER_OFFSET_Y);
            }
        }

        function createMascot(scene) {
            // Only para desktop
            if (window.innerWidth < 768) {
                isMascotVisible = false;
                return;
            }
            isMascotVisible = true;

            mascotBody = scene.add.image(0, 0, 'mascot_normal').setScrollFactor(0).setDepth(1000);
            mascotFace = mascotBody; // reuse body sprite for face swaps

            // Alavanca (posicionada à esquerda da coruja)
            mascotLever = scene.add.image(0, 0, 'lever_rest').setScrollFactor(0).setDepth(1000);

            positionMascot(scene.scale.width, scene.scale.height);
        }

        function updateMascotState(scene) {
            if (!isMascotVisible) return;
            const faceSprite = mascotFace || mascotBody;
            if (!faceSprite) return;

            // Detecta estado de Game Over
            const gameOverScreen = document.getElementById('game-over-screen');
            const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');
            if (gameOverVisible) {
                faceSprite.setTexture('mascot_sad'); // sad
                return;
            }

            // Lógica baseada em VIDAS (Lives)
            if (lives === 3) {
                faceSprite.setTexture('mascot_normal'); // Feliz (3 vidas)
            } else if (lives === 2) {
                faceSprite.setTexture('mascot_worried'); // Preocupado (2 vidas)
            } else {
                faceSprite.setTexture('mascot_worried2'); // Super Preocupado (1 vida)
            }
        }

        function triggerLever(scene) {
            if (!isMascotVisible) return;
            // Troca a textura da alavanca para o estado "puxada"
            mascotLever.setTexture('lever_pull');
            // Volta ao estado "levado" após 200ms
            scene.time.delayedCall(200, () => {
                if (mascotLever) mascotLever.setTexture('lever_rest');
            });
        }

        function startGame() {
            // console.log('Starting Game...');
            document.getElementById('game-over-screen').classList.add('hidden');
            const gc = document.getElementById('game-container');
            if (gc) gc.style.opacity = '1';

            // Show Debug Button only if admin is logged in (checked in script below)
            // const debugBtn = document.getElementById('debug-btn');
            // if (debugBtn) debugBtn.classList.remove('hidden');

            isGameActive = true;

            // Init/Resume Audio
            if (game) {
                const scene = game.scene.scenes[0];
                initAudio(scene);
                if (musicBg && !musicBg.isPlaying) musicBg.play();
            }

            score = 0;
            lives = 3; // Reset lives (ignored when god mode)
            currentGameMinY = null; // Reset current game tracking
            updateLivesUI();
            craneSpeed = gameConfig.baseSpeed;
            gameLog = []; // Reset anti-hack log

            // Draw record line from STORAGE (do not update it during game)
            if (game) {
                const scene = game.scene.scenes[0];

                // Draw record line from STORAGE (do not update it during game)
                if (recordLine) updateRecordLine(scene);

                // 1. Destroy all existing boxes
                boxes.forEach(box => {
                    if (box) {
                        scene.matter.world.remove(box);
                        if (box.destroy) box.destroy();
                    }
                });
                boxes = [];

                // 2. Destroy current/falling boxes if they exist
                if (currentBox) {
                    scene.matter.world.remove(currentBox);
                    if (currentBox.destroy) currentBox.destroy();
                    currentBox = null;
                }
                if (fallingBox) {
                    scene.matter.world.remove(fallingBox);
                    if (fallingBox.destroy) fallingBox.destroy();
                    fallingBox = null;
                }

                scene.scene.resume();
                scene.cameras.main.scrollY = 0; // Reset Camera
                if (background) background.tilePositionY = 0;
                crane.y = CRANE_Y; // Reset Crane

                updateScoreUI();

                // Reset physics gravity in case it changed
                scene.matter.world.setGravity(0, gameConfig.gravity);

                spawnBox(scene);
            } else {
                initGame();
                // Wait for scene to start then spawn
                setTimeout(() => {
                    const scene = game.scene.scenes[0];
                    scene.scene.resume();
                    spawnBox(scene);
                }, 500);
            }
        }

        // --- GAME OVER LOGIC ---
        let gameOverMenuIndex = 0; // 0: Save, 1: Restart
        let fallingBoxesInterval = null;

        // Track landed boxes for collision simulation
        let landedBoxes = [];

        function startGameOverRain() {
            const container = document.getElementById('game-over-screen');


            // Clear existing rain and reset tracking
            const existingRain = container.querySelectorAll('.rain-box');
            existingRain.forEach(el => el.remove());
            landedBoxes = [];

            // Finite number of boxes (TRIPLED: 45-75)
            const totalBoxes = Math.floor(Math.random() * 31) + 45;
            let boxesSpawned = 0;

            fallingBoxesInterval = setInterval(() => {
                if (boxesSpawned >= totalBoxes) {
                    clearInterval(fallingBoxesInterval);
                    return;
                }

                const box = document.createElement('img');
                box.className = 'rain-box';

                // Randomly select a sprite from availableSprites (squares only)
                let spriteSrc = 'assets/sprites/normal/1.png';
                const squareSprites = [...availableSprites.normal, ...availableSprites.goal]; // goal only has squares now

                if (squareSprites.length > 0) {
                    const randomKey = Phaser.Utils.Array.GetRandom(squareSprites);
                    if (randomKey.startsWith('normal_')) {
                        const num = randomKey.split('_')[1];
                        spriteSrc = `assets/sprites/normal/${num}.png`;
                    } else if (randomKey === 'goal_square') {
                        spriteSrc = `assets/sprites/heavy/${randomKey}.png`; // Corrected path for goal sprites
                    }
                }

                box.src = spriteSrc;

                // Random styling (DOUBLED SIZE: 60-140px)
                const size = Math.random() * 80 + 60; // 60px to 140px
                box.style.width = `${size}px`;
                box.style.height = `${size}px`;
                box.style.position = 'absolute';

                const leftPos = Math.random() * 85 + 5; // 5% to 90%
                box.style.left = leftPos + '%';
                box.style.top = '-150px'; // Start above screen
                box.style.opacity = '1';
                box.style.zIndex = '-1';
                box.style.imageRendering = 'pixelated';

                // Calculate landing height (simulate stacking)
                let landingHeight = 0; // Default: land on floor

                // Check for "collision" with existing boxes in similar horizontal position
                for (const landed of landedBoxes) {
                    const horizontalOverlap = Math.abs(landed.left - leftPos) < 15; // Within 15% range
                    if (horizontalOverlap && landed.top > landingHeight) {
                        landingHeight = landed.top; // Stack on top of this box
                    }
                }

                const finalTop = `calc(100% - ${size + landingHeight}px)`;

                // Animation - fall DOWN with realistic gravity (no excessive bounce)
                const duration = Math.random() * 2 + 1.5; // 1.5s to 3.5s
                box.style.transition = `top ${duration}s ease-in, transform ${duration}s ease-out`;
                // ease-in for gravity, ease-out for smooth rotation

                container.appendChild(box);

                // Trigger animation - fall to calculated position
                setTimeout(() => {
                    box.style.top = finalTop;
                    const initialRotation = Math.random() * 360;
                    box.style.transform = `rotate(${initialRotation}deg)`;

                    // After landing, add subtle rolling/settling physics
                    setTimeout(() => {
                        // Gentle rotation and minimal drift
                        const driftDirection = Math.random() > 0.5 ? 1 : -1;
                        const driftAmount = Math.random() * 1.5; // Reduced: 0-1.5% drift
                        const finalRotation = initialRotation + (Math.random() * 30 - 15); // Reduced: ±15° extra rotation

                        // Get current left position as number
                        const currentLeft = parseFloat(box.style.left);
                        const newLeft = Math.max(0, Math.min(95, currentLeft + (driftDirection * driftAmount)));

                        // Gentle settling animation (subtle roll and drift)
                        box.style.transition = 'transform 0.5s ease-out, left 0.5s ease-out';
                        box.style.transform = `rotate(${finalRotation}deg)`;
                        box.style.left = newLeft + '%';
                    }, duration * 1000);

                    // Track this box for future collisions
                    setTimeout(() => {
                        landedBoxes.push({
                            left: leftPos,
                            top: size + landingHeight
                        });
                    }, duration * 1000);
                }, 50);

                boxesSpawned++;
            }, 80); // Spawn faster (every 80ms)
        }






        function stopGameOverRain() {
            if (fallingBoxesInterval) {
                clearInterval(fallingBoxesInterval);
                fallingBoxesInterval = null;
            }
            // Remove all existing boxes
            document.querySelectorAll('.falling-box').forEach(el => el.remove());
        }

        function updateGameOverMenu() {
            const buttons = [document.getElementById('ranking-btn'), document.getElementById('restart-btn')];
            buttons.forEach((btn, index) => {
                if (index === gameOverMenuIndex) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        function gameOver() {
            isGameActive = false;
            if (game) {
                // Stop music and play game over sound
                if (musicBg) musicBg.stop();
                playSound(game.scene.scenes[0], 'sfx_gameover', { volume: 0.3 });

                // Show sad face immediately
                if (mascotFace) {
                    mascotFace.setTexture('mascot_sad');
                }
                const gc = document.getElementById('game-container');
                if (gc) gc.style.opacity = '0';
                game.scene.pause('default');

                // Update Session Record if current game beat it
                if (currentGameMinY !== null) {
                    if (sessionBestY === null || currentGameMinY < sessionBestY) {
                        sessionBestY = currentGameMinY;
                        sessionStorage.setItem('sessionBestY', sessionBestY);
                        // Note: We don't redraw the line here, it will update next game
                    }
                }

                const finalScore = score; // Use global score variable
                logEvent('GAME_OVER', { score: finalScore });
                const scoreElement = document.getElementById('final-score');
                if (scoreElement) scoreElement.innerText = 'SCORE: ' + finalScore;

                // Show/hide clear button based on localStorage
                const clearBtn = document.getElementById('clear-btn');
                const savedName = localStorage.getItem('playerName');
                if (clearBtn) {
                    clearBtn.style.display = savedName ? 'block' : 'none';
                }

                const gameOverScreen = document.getElementById('game-over-screen');
                if (gameOverScreen) {
                    gameOverScreen.classList.remove('hidden');
                    gameOverScreen.style.display = 'flex'; // Force display flex

                    // Start Rain
                    startGameOverRain();

                    // Reset Menu
                    gameOverMenuIndex = 0;
                    updateGameOverMenu();
                }

                // Focus on first input
                setTimeout(() => {
                    const firstInput = document.getElementById('char1');
                    if (firstInput) firstInput.focus();
                }, 100);

                logEvent('GAME_OVER', { score: finalScore });
            }
        }

        // --- ANTI-HACK LOG SYSTEM ---
        let gameLog = [];

        function logEvent(action, details = {}) {
            gameLog.push({
                ts: Date.now(),
                action: action,
                ...details
            });
            // console.log('Log:', action, details);
        }

        function updateLivesUI() {
            const container = document.getElementById('lives-display');
            if (!container) return;
            container.innerHTML = ''; // Clear

            // Always show 3 hearts
            for (let i = 0; i < 3; i++) {
                const img = document.createElement('img');
                // If index is less than current lives, show filled heart. Otherwise, show empty heart.
                if (i < lives) {
                    // Filled Heart
                    img.src = 'assets/sprites/heart/heart-full.svg';
                } else {
                    // Empty Heart
                    img.src = 'assets/sprites/heart/heart-empty.svg';
                }
                img.className = 'heart-icon';
                img.id = `heart-${i}`; // Add ID for targeting
                container.appendChild(img);
            }
        }

        function handleLifeLoss(scene, box) {
            const infiniteLives = godMode;
            // Prevent multiple triggers for the same box
            if (box.hasCausedDamage) return;
            box.hasCausedDamage = true;

            // 1. Red Flash
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.5';
                setTimeout(() => {
                    overlay.style.opacity = '0';
                }, 150);
            }

            // Play heart loss sound
            playSound(scene, 'sfx_heart_lost', { volume: 0.7 });

            // 2. Falling Heart Animation
            // We are about to lose life at index `lives - 1`
            const heartIndex = lives - 1;
            const heartElement = document.getElementById(`heart-${heartIndex}`);

            if (heartElement) {
                // Create a clone for animation
                const rect = heartElement.getBoundingClientRect();
                const fallingHeart = heartElement.cloneNode(true);
                fallingHeart.style.position = 'fixed';
                fallingHeart.style.left = rect.left + 'px';
                fallingHeart.style.top = rect.top + 'px';
                fallingHeart.style.zIndex = '1000';
                fallingHeart.style.transition = 'transform 1s ease-in, opacity 1s ease-in';
                document.body.appendChild(fallingHeart);

                // Animate Fall
                requestAnimationFrame(() => {
                    fallingHeart.style.transform = `translateY(300px) rotate(45deg)`;
                    fallingHeart.style.opacity = '0';
                });

                // Cleanup
                setTimeout(() => {
                    fallingHeart.remove();
                }, 1000);
            }

            if (!infiniteLives) {
                lives--;
                updateLivesUI();
            }

            // Check for game over before continuing
            if (!infiniteLives && lives <= 0) {
                // Clean up the fallen box before ending the game
                if (box) {
                    const index = boxes.indexOf(box);
                    if (index > -1) boxes.splice(index, 1);
                    scene.matter.world.remove(box);
                    box.destroy();
                }
                gameOver();
                return;
            }

            // Destroy the box
            if (box) {
                // Remove from boxes array
                const index = boxes.indexOf(box);
                if (index > -1) {
                    boxes.splice(index, 1);
                }
                // Remove from physics world and destroy
                scene.matter.world.remove(box);
                box.destroy();
                if (box === fallingBox) {
                    fallingBox = null;
                    // Spawn new box after a delay
                    scene.time.delayedCall(500, () => spawnBox(scene));
                } else {
                    // It was a static box that fell.
                    // If no boxes left, we might need to ensure gameplay continues.
                    if (boxes.length === 0 && !fallingBox) {
                        scene.time.delayedCall(500, () => spawnBox(scene));
                    }
                }
                // If the box that fell was the `fallingBox`
                if (box === fallingBox) {
                    fallingBox = null;
                    scene.time.delayedCall(500, () => spawnBox(scene));
                }
            }
        }




        function updateRecordLine(scene) {
            if (!recordLine) return;
            recordLine.clear();
            if (sessionBestY !== null) {
                const dash = 8;
                const gap = 6;
                const y = sessionBestY;
                // Shadow
                recordLine.lineStyle(6, 0x000000, 0.35);
                for (let x = 0; x < scene.scale.width; x += dash + gap) {
                    recordLine.moveTo(x, y + 1);
                    recordLine.lineTo(x + dash, y + 1);
                }
                recordLine.strokePath();
                // Main line - WHITE
                recordLine.lineStyle(1, 0xffffff, 0.9);
                for (let x = 0; x < scene.scale.width; x += dash + gap) {
                    recordLine.moveTo(x, y);
                    recordLine.lineTo(x + dash, y);
                }
                recordLine.strokePath();

                const cam = scene.cameras.main;
                const screenY = y - cam.scrollY;
                if (!recordLineLabel) {
                    // CHANGED TO LEFT SIDE (20px)
                    recordLineLabel = scene.add.text(20, screenY - 12, 'SEU RECORD', {
                        fontFamily: '"Press Start 2P"',
                        fontSize: '10px',
                        color: '#888888', // Gray text
                        backgroundColor: '#ffffff', // White background
                        padding: { x: 6, y: 4 }
                    });
                    recordLineLabel.setDepth(1000);
                    recordLineLabel.setScrollFactor(0);
                } else {
                    recordLineLabel.setPosition(20, screenY - 12);
                    recordLineLabel.setText('SEU RECORD');
                    recordLineLabel.setStyle({ backgroundColor: '#ffffff', color: '#888888' }); // Update style if exists
                }
            }

            // Ranking lines (other players) - TOP 3 ONLY
            if (rankingLines.length === 0 && rankingHeights.length > 0) {
                // Load full ranking data with names
                const rankingData = JSON.parse(localStorage.getItem('highScores') || '[]')
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 3); // Only top 3

                rankingHeights.slice(0, 3).forEach((y, idx) => {
                    // Medal colors: Gold, Silver, Bronze
                    const medalColors = ['#FFD700', '#C0C0C0', '#CD7F32'];
                    const bgColor = medalColors[idx];

                    // Get player name from ranking data
                    const playerName = rankingData[idx] ? rankingData[idx].playerName : 'TOP';

                    rankingLines.push({
                        y,
                        idx,
                        gfx: scene.add.graphics(),
                        bgColor, // Store for line drawing
                        // CHANGED TO LEFT SIDE (10px)
                        label: scene.add.text(10, 0, `TOP ${idx + 1} - ${playerName}`, {
                            fontFamily: '"Press Start 2P"',
                            fontSize: '10px',
                            color: '#000',
                            backgroundColor: bgColor,
                            padding: { x: 4, y: 3 }
                        }).setDepth(900).setScrollFactor(0),
                        passed: false
                    });
                });
            }

            rankingLines.forEach(line => {
                const g = line.gfx;
                g.clear();
                const dash = 6;
                const gap = 5;
                const y = line.y;
                // Shadow
                g.lineStyle(5, 0x000000, 0.25);
                for (let x = 0; x < scene.scale.width; x += dash + gap) {
                    g.moveTo(x, y + 1);
                    g.lineTo(x + dash, y + 1);
                }
                g.strokePath();
                // Main line - use medal color
                const lineColor = parseInt(line.bgColor.replace('#', ''), 16);
                g.lineStyle(1, lineColor, 0.9);
                for (let x = 0; x < scene.scale.width; x += dash + gap) {
                    g.moveTo(x, y);
                    g.lineTo(x + dash, y);
                }
                g.strokePath();

                const cam = scene.cameras.main;
                const screenY = y - cam.scrollY;
                // CHANGED TO LEFT SIDE (10px)
                line.label.setPosition(10, screenY - 10);

                // Pass notification
                if (!line.passed && currentGameMinY !== null && currentGameMinY < y) {
                    line.passed = true;
                    // Play sound only for top 3
                    if (line.idx < 3) {
                        playSound(scene, 'sfx_score_pass', { volume: 0.4 });
                    }
                    // CHANGED TO LEFT SIDE (20px) - VERTICALLY CENTERED
                    const ping = scene.add.text(20, scene.scale.height / 2 - 16, `PASSOU TOP${line.idx + 1}!`, {
                        fontFamily: '"Press Start 2P"',
                        fontSize: '20px',
                        color: '#ffffff',
                        backgroundColor: line.bgColor, // Use medal color
                        padding: { x: 6, y: 4 }
                    }).setDepth(1200).setScrollFactor(0);
                    scene.tweens.add({
                        targets: ping,
                        alpha: 0,
                        y: scene.scale.height / 2 - 66, // Move UP (was screenY - 50)
                        duration: 800,
                        onComplete: () => ping.destroy()
                    });
                }
            });
        }

        document.addEventListener('keydown', (e) => {
            const gameOverScreen = document.getElementById('game-over-screen');
            if (!gameOverScreen || gameOverScreen.classList.contains('hidden')) return;

            // If typing in input, ignore arrows unless they are for navigation between inputs (handled by browser)
            // But we want to navigate buttons if inputs are NOT focused or if we press Down from inputs?
            // Let's keep it simple: Up/Down always navigates buttons if we are not typing?
            // Actually user said "using keyboard keys to change selection".

            if (e.key === 'ArrowUp') {
                gameOverMenuIndex = (gameOverMenuIndex - 1 + 2) % 2;
                updateGameOverMenu();
            } else if (e.key === 'ArrowDown') {
                gameOverMenuIndex = (gameOverMenuIndex + 1) % 2;
                updateGameOverMenu();
            } else if (e.key === 'Enter') {
                // Shortcut: Enter to Restart immediately
                document.getElementById('restart-btn').click();
            }
        });

        // --- UI & ADMIN LOGIC ---

        // --- UI & ADMIN LOGIC ---

        // Auto-start logic for game.html
        window.onload = async () => {
            // console.log('Game page loaded. Auto-starting...');

            // Retrieve player name from localStorage or default
            playerName = localStorage.getItem('playerName') || 'JOG';

            try {
                // Load sprites from Firestore
                await loadCustomSprites();

                // Timeout for config load to prevent hanging
                const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 2000));
                await Promise.race([loadGameConfig(), timeoutPromise]);
            } catch (e) {
                console.warn('Config load skipped or failed:', e);
            }

            // Ensure game variable is initialized if not already
            if (typeof game === 'undefined' || !game) {
                initGame();
                // Wait for game AND scene to be ready before starting
                const checkGameReady = setInterval(() => {
                    if (game && isSceneReady) {
                        clearInterval(checkGameReady);
                        // console.log('Game and Scene ready, calling startGame...');
                        startGame();
                    }
                }, 100);
            } else {
                // console.log('Game already initialized, calling startGame...');
                startGame();
            }
        };

        // --- UI EVENT LISTENERS ---
        document.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (game && game.scene && game.scene.scenes[0]) {
                    playSound(game.scene.scenes[0], 'sfx_ui_click', { volume: 0.5 });
                }
            });
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            location.reload();
        });

        // Ranking Button Logic
        document.getElementById('ranking-btn').addEventListener('click', () => {
            // Delay redirect to allow sound to play
            setTimeout(() => {
                window.location.href = 'ranking.html';
            }, 200);
        });

        // Name Input Logic
        const nameInputs = document.querySelectorAll('.char-input');
        nameInputs.forEach((input, index) => {
            input.addEventListener('input', (e) => {
                if (input.value.length === 1) {
                    if (index < nameInputs.length - 1) nameInputs[index + 1].focus();
                }
            });
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Backspace' && input.value.length === 0) {
                    if (index > 0) nameInputs[index - 1].focus();
                }
            });
        });

        document.getElementById('save-score-btn').addEventListener('click', async () => {
            // Construct name from inputs
            const nameFromInputs =
                (document.getElementById('char1').value || '') +
                (document.getElementById('char2').value || '') +
                (document.getElementById('char3').value || '') +
                (document.getElementById('char4').value || '') +
                (document.getElementById('char5').value || '') +
                (document.getElementById('char6').value || '') +
                (document.getElementById('char7').value || '') +
                (document.getElementById('char8').value || '');

            if (nameFromInputs.length >= 3) {
                playerName = nameFromInputs.toUpperCase();
            }

            // Silent fail if name is too short
            if (playerName.length < 3) {
                return;
            }

            // UI Feedback: Saving state
            const saveBtn = document.getElementById('save-score-btn');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerText = "SALVANDO...";
            saveBtn.disabled = true;
            saveBtn.style.opacity = "0.7";
            saveBtn.style.cursor = "not-allowed";

            const newScore = {
                playerName: playerName,
                score: score,
                timestamp: new Date().toISOString()
            };

            // Save to LocalStorage
            let highScores = JSON.parse(localStorage.getItem('highScores') || '[]');
            highScores.push(newScore);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10); // Keep top 10
            localStorage.setItem('highScores', JSON.stringify(highScores));

            // Firebase Logic
            if (isFirebaseReady) {
                try {
                    // Collect anti-hack game log
                    const gameLog = {
                        totalBoxes: boxes.length,
                        finalScore: score,
                        gameSpeed: craneSpeed,
                        difficulty: gameConfig.difficultyMultiplier,
                        gravity: gameConfig.gravity,
                        playDuration: Math.floor((Date.now() - gameStartTime) / 1000), // seconds
                        boxTypes: boxes.map(box => box.boxType || 'normal'),
                        secondsSinceLastClick: Math.floor((Date.now() - lastMouseClickTs) / 1000),
                        userAgent: navigator.userAgent,
                        screenResolution: `${window.innerWidth}x${window.innerHeight}`,
                        timestamp: new Date().toISOString()
                    };

                    // Add a new document with a generated id.
                    await addDoc(collection(db, "scores"), {
                        playerName: playerName,
                        score: score,
                        timestamp: new Date(), // Firestore will store as timestamp
                        gameLog: gameLog // Anti-hack data
                    });

                    // Wait a moment to ensure Firebase write completes
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (e) {
                    console.error("Error adding document: ", e);
                    saveBtn.innerText = "ERRO AO SALVAR";
                    setTimeout(() => {
                        saveBtn.innerHTML = originalText;
                        saveBtn.disabled = false;
                        saveBtn.style.opacity = "1";
                        saveBtn.style.cursor = "pointer";
                    }, 1200);
                    return;
                }
            }

            // Success feedback and clear inputs
            saveBtn.innerText = "SALVO!";
            // Clear nickname inputs
            for (let i = 1; i <= 8; i++) {
                const input = document.getElementById(`char${i}`);
                if (input) input.value = '';
            }
            // Delay redirect to allow sound to play
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1200);
        });

        // --- DYNAMIC ADMIN PANEL ---

        // --- DYNAMIC ADMIN PANEL ---

        // Return to Start Screen
        document.getElementById('game-over-screen').classList.add('hidden');
        // Removed old admin-login-btn listener as per instructions.
        // document.getElementById('admin-login-btn').addEventListener('click', () => {
        //     // Password check removed as requested
        //     // const pass = document.getElementById('admin-pass').value;
        //     // if (pass === "admin123") {
        //     adminControls.style.display = 'block';
        //     document.getElementById('admin-login-btn').style.display = 'none';
        //     // Hide password input too since it's not needed
        //     document.getElementById('admin-pass').style.display = 'none';
        //     const passLabel = document.querySelector('label[for="admin-pass"]');
        //     if (passLabel) passLabel.style.display = 'none';

        //     // Load current values into inputs
        //     document.getElementById('cfg-gravity').value = gameConfig.gravity;
        //     document.getElementById('cfg-speed').value = gameConfig.baseSpeed;
        //     document.getElementById('cfg-diff').value = gameConfig.difficultyMultiplier;
        //     // } else {
        //     //     alert("Senha Incorreta!");
        //     // }
        // });

        // Sprite Upload Logic
        // This function is now integrated into renderAdminPanel and its calls are removed.
        // function handleSpriteUpload(inputId, textureKey) {
        //     document.getElementById(inputId).addEventListener('change', (e) => {
        //         const file = e.target.files[0];
        //         if (!file) return;

        //         const reader = new FileReader();
        //         reader.onload = (event) => {
        //             const img = new Image();
        //             img.src = event.target.result;
        //             img.onload = () => {
        //                 if (game) {
        //                     // Add new texture
        //                     const customKey = textureKey + '_custom';
        //                     if (game.textures.exists(customKey)) {
        //                         game.textures.remove(customKey);
        //                     }
        //                     game.textures.addImage(customKey, img);
        //                     alert(`Sprite ${textureKey} atualizado! Próximas caixas usarão o novo sprite.`);
        //                 }
        //             };
        //         };
        //         reader.readAsDataURL(file);
        //     });
        // }

        // handleSpriteUpload('upload-box', 'box');
        // handleSpriteUpload('upload-box-goal', 'box_goal');

        // Update Save Logic
        // Update Save Logic
        // --- GLOBAL SHORTCUTS (Document Level) ---
        document.addEventListener('keydown', (event) => {
            const key = event.key;
            // console.log('Global Keydown:', key);

            const gameOverScreen = document.getElementById('game-over-screen');

            const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');

            if (gameOverVisible) {
                if (key === 'Enter') {
                    // console.log('Global Shortcut: Save Score');
                    const saveBtn = document.getElementById('save-score-btn');
                    if (saveBtn) saveBtn.click();
                    event.preventDefault();
                } else if (key === ' ') {
                    // console.log('Global Shortcut: Restart Game');
                    startGame();
                    event.preventDefault();
                } else if (key === 'r' || key === 'R') {
                    window.location.href = 'ranking.html';
                    event.preventDefault();
                } else if (key === 'Escape') {
                    window.location.href = 'index.html';
                    event.preventDefault();
                }
            }
        });

        // Check for Game Over test param
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('gameover') === 'true') {
            // Wait a brief moment for assets/DOM to be ready
            setTimeout(() => {
                gameOver();
            }, 500);
        }
    </script>

    <!-- Game Over Screen - Placed at end for proper z-index stacking -->
    <div id="game-over-screen" class="hidden"
        style="position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: 100% !important; background: none; justify-content: center; align-items: center; z-index: 10000 !important;">
        <!-- Content Wrapper (Above Falling Boxes) -->
        <div class="game-over-content"
            style="background: none; border: none; box-shadow: none; padding: 0; margin-top: 60px;">
            <!-- Group 1: Image -->
            <div style="display: flex; gap: 20px; align-items: center; justify-content: center; margin-bottom: 48px;">
                <img src="assets/game_over/game_text.png" alt="GAME"
                    style="width: 40%; max-width: 200px; image-rendering: pixelated; animation: pulse-grow 2s infinite ease-in-out;">
                <img src="assets/game_over/over_text.png" alt="OVER"
                    style="width: 40%; max-width: 200px; image-rendering: pixelated; animation: pulse-shrink 2s infinite ease-in-out;">
            </div>

            <!-- Group 2: Score -->
            <div id="final-score"
                style="font-size: 32px; color: #fff; text-shadow: 4px 4px 0px #000; margin-bottom: 48px;">SCORE: 0</div>

            <!-- Group 3: Nickname & Save -->
            <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 48px;">
                <div style="color: #fff; font-size: 20px; margin-bottom: 5px; font-family: 'Press Start 2P', cursive;">
                    APELIDO</div>

                <div class="input-group">
                    <input type="text" maxlength="1" class="char-input" id="char1">
                    <input type="text" maxlength="1" class="char-input" id="char2">
                    <input type="text" maxlength="1" class="char-input" id="char3">
                    <input type="text" maxlength="1" class="char-input" id="char4">
                    <input type="text" maxlength="1" class="char-input" id="char5">
                    <input type="text" maxlength="1" class="char-input" id="char6">
                    <input type="text" maxlength="1" class="char-input" id="char7">
                    <input type="text" maxlength="1" class="char-input" id="char8">
                </div>

                <div style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                    <button class="pixel-btn" id="save-score-btn"
                        style="width: 100%; font-size: 16px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000;">SALVAR</button>
                    <button class="pixel-btn" id="ranking-btn"
                        style="width: 100%; font-size: 16px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000; padding: 15px;">RANKING</button>
                </div>
            </div>

            <!-- Group 4: Buttons -->
            <div style="display: flex; flex-direction: column; gap: 15px; width: 100%;">
                <button class="pixel-btn" id="restart-btn"
                    style="width: 100%; font-size: 16px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000;">TENTAR
                    DE NOVO</button>
                <button class="pixel-btn" onclick="window.location.href='index.html'"
                    style="width: 100%; font-size: 16px; background: #fff; border: 4px solid #fff; color: #000; box-shadow: 4px 4px 0px #000;">SAIR
                    <span class="shortcut-key">[ESC]</span></button>
            </div>
        </div>
    </div>

    <!-- Debug Sidebar -->
    <div id="debug-sidebar"
        style="position: fixed; top: 0; left: -350px; width: 300px; height: 100%; background: rgba(10, 10, 20, 0.95); border-right: 2px solid #00ffff; z-index: 10001; transition: left 0.3s ease; padding: 20px; color: #fff; font-family: 'Press Start 2P'; overflow-y: auto; box-shadow: 5px 0 15px rgba(0,0,0,0.5);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="margin: 0; font-size: 16px; color: #00ffff;">CONFIGURAÇÕES</h2>
            <button id="close-debug-btn"
                style="background: none; border: none; color: #ff4444; font-size: 20px; cursor: pointer;">X</button>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">GRAVIDADE (Y)</label>
            <input type="range" id="debug-gravity" min="0" max="5" step="0.1" value="1" style="width: 100%;">
            <span id="val-gravity"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">1.0</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">VELOCIDADE
                GUINDASTE</label>
            <input type="range" id="debug-speed" min="1" max="10" step="0.5" value="2" style="width: 100%;">
            <span id="val-speed" style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">2.0</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">MULTIPLICADOR
                DIFICULDADE</label>
            <input type="range" id="debug-difficulty" min="0" max="1" step="0.05" value="0.1" style="width: 100%;">
            <span id="val-difficulty"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">0.1</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">ATRITO (FRICTION)</label>
            <input type="range" id="debug-friction" min="0" max="1" step="0.05" value="0.5" style="width: 100%;">
            <span id="val-friction"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">0.5</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">QUICAR (BOUNCE)</label>
            <input type="range" id="debug-bounce" min="0" max="1" step="0.05" value="0.1" style="width: 100%;">
            <span id="val-bounce"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">0.1</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">CHANCE CAIXA META
                (%)</label>
            <input type="range" id="debug-goal-chance" min="0" max="30" step="1" value="10" style="width: 100%;">
            <span id="val-goal-chance"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">10</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">DENSIDADE CAIXA
                META</label>
            <input type="range" id="debug-goal-density" min="0.02" max="0.12" step="0.005" value="0.07"
                style="width: 100%;">
            <span id="val-goal-density"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">0.07</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">CHANCE CAIXA GELO
                (%)</label>
            <input type="range" id="debug-ice-chance" min="0" max="30" step="1" value="10" style="width: 100%;">
            <span id="val-ice-chance"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">10</span>
        </div>

        <div class="debug-control-group" style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 10px; color: #aaa;">FRIÇÃO CAIXA GELO</label>
            <input type="range" id="debug-ice-friction" min="0" max="0.2" step="0.005" value="0.08"
                style="width: 100%;">
            <span id="val-ice-friction"
                style="display: block; text-align: right; font-size: 10px; margin-top: 5px;">0.08</span>
        </div>

        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button id="apply-config-btn" class="pixel-btn"
                style="flex: 1; font-size: 10px; padding: 10px; background-color: #00ffff; color: #000; border-color: #fff;">APLICAR</button>
            <button id="reset-config-btn" class="pixel-btn"
                style="flex: 1; font-size: 10px; padding: 10px; background-color: #ff4444; color: #fff; border-color: #fff;">RESET</button>
        </div>

        <div style="margin-top: 30px; border-top: 1px solid #333; padding-top: 20px;">
            <p style="font-size: 8px; color: #666; line-height: 1.5;">
                * Alterações aplicadas em tempo real.<br>
                * Não salva no banco de dados.<br>
                * Use para testar estabilidade.
            </p>
        </div>
    </div>

    <script>
        // Sound Toggle Logic
        // Sound Toggle Logic
        const soundBtn = document.getElementById('sound-btn');
        const soundIcon = document.getElementById('sound-icon');

        // Initialize from localStorage
        let isMuted = localStorage.getItem('isMuted') === 'true';
        soundEnabled = !isMuted;

        // Apply initial state
        if (isMuted) {
            soundIcon.src = 'assets/sprites/icons/no-audio.svg';
        } else {
            soundIcon.src = 'assets/sprites/icons/audio.svg';
        }

        soundBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            soundEnabled = !isMuted;
            localStorage.setItem('isMuted', isMuted); // Save state

            // Update icon
            if (isMuted) {
                soundIcon.src = 'assets/sprites/icons/no-audio.svg';
                if (musicBg && musicBg.setMute) {
                    musicBg.setMute(true);
                }
            } else {
                soundIcon.src = 'assets/sprites/icons/audio.svg';
                if (musicBg && musicBg.setMute) {
                    musicBg.setMute(false);
                }
            }
        });

        // Reset Button Logic
        const resetGameBtn = document.getElementById('reset-game-btn');
        if (resetGameBtn) {
            resetGameBtn.addEventListener('click', () => {
                location.reload();
            });
        }

        // Global 'R' key for reset (only if not in input)
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            // If 'R' is pressed and game is active (or even if not, as requested "reset")
            // Note: Existing code uses 'R' for Ranking in Game Over screen. 
            // We should prioritize the Reset function if the user explicitly asked for it on the game screen.
            // However, to avoid conflict, let's check if Game Over is visible.
            const gameOverScreen = document.getElementById('game-over-screen');
            const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');

            if (e.key.toLowerCase() === 'r' && !gameOverVisible) {
                location.reload();
            }
        });

        // Debug Sidebar Logic
        const debugBtn = document.getElementById('debug-btn');
        const debugSidebar = document.getElementById('debug-sidebar');
        const closeDebugBtn = document.getElementById('close-debug-btn');

        // Check if admin is logged in (session check)
        const isAdminLoggedIn = sessionStorage.getItem('adminLoggedIn') === 'true';
        if (isAdminLoggedIn) {
            debugBtn.classList.remove('hidden');
        }

        // Hide God Mode button unless admin is logged in
        const godBtn = document.getElementById('god-btn');
        if (!isAdminLoggedIn) {
            godBtn.style.display = 'none';
        }

        // Inputs
        const inputGravity = document.getElementById('debug-gravity');
        const inputSpeed = document.getElementById('debug-speed');
        const inputDifficulty = document.getElementById('debug-difficulty');
        const inputFriction = document.getElementById('debug-friction');
        const inputBounce = document.getElementById('debug-bounce');
        const inputGoalChance = document.getElementById('debug-goal-chance');
        const inputGoalDensity = document.getElementById('debug-goal-density');
        const inputIceChance = document.getElementById('debug-ice-chance');
        const inputIceFriction = document.getElementById('debug-ice-friction');

        // Value Displays
        const valGravity = document.getElementById('val-gravity');
        const valSpeed = document.getElementById('val-speed');
        const valDifficulty = document.getElementById('val-difficulty');
        const valFriction = document.getElementById('val-friction');
        const valBounce = document.getElementById('val-bounce');
        const valGoalChance = document.getElementById('val-goal-chance');
        const valGoalDensity = document.getElementById('val-goal-density');
        const valIceChance = document.getElementById('val-ice-chance');
        const valIceFriction = document.getElementById('val-ice-friction');

        // Toggle Sidebar
        debugBtn.addEventListener('click', () => {
            debugSidebar.style.left = '0';
            // Squeeze Game Content
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.style.transition = 'margin-left 0.3s ease, width 0.3s ease';
                gameContainer.style.marginLeft = '300px';
                gameContainer.style.width = 'calc(100% - 300px)';

                // Trigger Phaser Resize after transition
                setTimeout(() => {
                    if (game) {
                        game.scale.resize(gameContainer.clientWidth, gameContainer.clientHeight);
                    }
                }, 350);
            }

            // Sync values with current game state
            if (typeof gameConfig !== 'undefined') {
                inputGravity.value = gameConfig.gravity;
                valGravity.innerText = gameConfig.gravity;

                inputSpeed.value = gameConfig.baseSpeed;
                valSpeed.innerText = gameConfig.baseSpeed;

                inputDifficulty.value = gameConfig.difficultyMultiplier;
                valDifficulty.innerText = gameConfig.difficultyMultiplier;

                const goalType = boxTypes.find(t => t.category === 'goal');
                if (goalType) {
                    inputGoalChance.value = goalType.chance;
                    valGoalChance.innerText = goalType.chance;
                    const baseDensity = goalType.densityRange ? (goalType.densityRange[0] + goalType.densityRange[1]) / 2 : goalType.density || 0.07;
                    inputGoalDensity.value = baseDensity;
                    valGoalDensity.innerText = baseDensity.toFixed(3);
                }

                const iceType = boxTypes.find(t => t.category === 'ice');
                if (iceType) {
                    inputIceChance.value = iceType.chance;
                    valIceChance.innerText = iceType.chance;
                    inputIceFriction.value = iceType.friction;
                    valIceFriction.innerText = iceType.friction.toFixed(3);
                }
            }
        });

        closeDebugBtn.addEventListener('click', () => {
            debugSidebar.style.left = '-350px';
            // Reset Game Content Position
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.style.marginLeft = '0';
                gameContainer.style.width = '100%';

                // Trigger Phaser Resize after transition
                setTimeout(() => {
                    if (game) {
                        game.scale.resize(window.innerWidth, window.innerHeight);
                    }
                }, 350);
            }
        });

        // Real-time Updates (UI Only)
        inputGravity.addEventListener('input', (e) => { document.getElementById('val-gravity').innerText = e.target.value; });
        inputSpeed.addEventListener('input', (e) => { document.getElementById('val-speed').innerText = e.target.value; });
        inputDifficulty.addEventListener('input', (e) => { document.getElementById('val-difficulty').innerText = e.target.value; });
        inputFriction.addEventListener('input', (e) => { document.getElementById('val-friction').innerText = e.target.value; });
        inputBounce.addEventListener('input', (e) => { document.getElementById('val-bounce').innerText = e.target.value; });
        inputGoalChance.addEventListener('input', (e) => { document.getElementById('val-goal-chance').innerText = e.target.value; });
        inputGoalDensity.addEventListener('input', (e) => { document.getElementById('val-goal-density').innerText = parseFloat(e.target.value).toFixed(3); });
        inputIceChance.addEventListener('input', (e) => { document.getElementById('val-ice-chance').innerText = e.target.value; });
        inputIceFriction.addEventListener('input', (e) => { document.getElementById('val-ice-friction').innerText = parseFloat(e.target.value).toFixed(3); });

        // Apply Config Logic
        document.getElementById('apply-config-btn').addEventListener('click', () => {
            // console.log("Applying config...");
            if (typeof gameConfig !== 'undefined') {
                gameConfig.gravity = parseFloat(inputGravity.value);
                gameConfig.baseSpeed = parseFloat(inputSpeed.value);
                gameConfig.difficultyMultiplier = parseFloat(inputDifficulty.value);
                const goalChance = parseFloat(inputGoalChance.value);
                const goalDensity = parseFloat(inputGoalDensity.value);
                const iceChance = parseFloat(inputIceChance.value);
                const iceFriction = parseFloat(inputIceFriction.value);

                // Apply to Game
                if (game) {
                    // Try to get the running scene
                    const scene = game.scene.getScene('default') || game.scene.scenes[0];

                    if (scene && scene.matter) {
                        scene.matter.world.setGravity(0, gameConfig.gravity);
                        // console.log("Gravity applied:", gameConfig.gravity);
                    }

                    // Update Crane Speed
                    if (typeof craneSpeed !== 'undefined') {
                        craneSpeed = gameConfig.baseSpeed + (score * gameConfig.difficultyMultiplier);
                    }

                    // Update Box Physics
                    const friction = parseFloat(inputFriction.value);
                    const bounce = parseFloat(inputBounce.value);
                    updateBoxPhysics('friction', friction);
                    updateBoxPhysics('bounce', bounce);

                    // Update goal boxes chance and density
                    boxTypes = boxTypes.map(t => {
                        if (t.category === 'goal') {
                            return {
                                ...t,
                                chance: goalChance,
                                densityRange: [goalDensity * 0.9, goalDensity * 1.1]
                            };
                        } else if (t.category === 'ice') {
                            return { ...t, chance: iceChance, friction: iceFriction };
                        } else if (t.category === 'iceRect') {
                            return { ...t, chance: iceChance, friction: iceFriction * 0.8 };
                        }
                        return t;
                    });

                    alert("Configurações Aplicadas com Sucesso!");
                } else {
                    console.error("Game instance not found!");
                }
            }
        });

        // Reset Config Logic
        document.getElementById('reset-config-btn').addEventListener('click', () => {
            // Reset inputs to defaults
            inputGravity.value = 1; document.getElementById('val-gravity').innerText = "1";
            inputSpeed.value = 2; document.getElementById('val-speed').innerText = "2";
            inputDifficulty.value = 0.1; document.getElementById('val-difficulty').innerText = "0.1";
            inputFriction.value = 0.5; document.getElementById('val-friction').innerText = "0.5";
            inputBounce.value = 0.1; document.getElementById('val-bounce').innerText = "0.1";

            // Trigger Apply
            document.getElementById('apply-config-btn').click();
        });

        // Responsive Resize Listener
        window.addEventListener('resize', () => {
            if (game) {
                const width = window.innerWidth;
                const height = window.innerHeight;

                game.scale.resize(width, height);

                // Update background size if needed
                if (game.scene.scenes[0]) {
                    updateBackgroundGradient(game.scene.scenes[0], true);
                }

                // Update Mascot Visibility & Position
                if (mascotBody) {
                    const isDesktop = width >= 768;
                    isMascotVisible = isDesktop;
                    mascotBody.setVisible(isDesktop);
                    if (mascotLever) mascotLever.setVisible(isDesktop);

                    if (isDesktop) {
                        positionMascot(width, height);
                    }
                }
            }
        });

    </script>
</body>

</html>