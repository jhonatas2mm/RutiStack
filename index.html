<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Equilíbrio da Coruja</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0f0f1e;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .pixel-btn {
            background-color: #ffcc00;
            border: 4px solid #fff;
            box-shadow: 4px 4px 0px #000;
            color: #000;
            font-family: 'Press Start 2P', cursive;
            padding: 15px 20px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            text-transform: uppercase;
            transition: transform 0.1s;
        }

        .pixel-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px #000;
        }

        .pixel-box {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #fff;
            padding: 20px;
            text-align: center;
            pointer-events: auto;
        }

        .menu-btn {
            background: none;
            border: none;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            cursor: pointer;
            text-transform: uppercase;
            padding: 10px 30px;
            /* Add horizontal padding for arrow space */
            position: relative;
            transition: color 0.2s;
            text-align: center;
            width: auto;
            /* Fit content */
            white-space: nowrap;
        }

        .menu-btn:hover,
        .menu-btn.selected {
            color: #00ffff;
        }

        .menu-btn:hover::before,
        .menu-btn.selected::before {
            content: '> ';
            position: absolute;
            left: 0px;
            /* Position at the start of padding */
            color: #00ffff;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000a2e;
            background-image: url('assets/start_screen/background.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            /* Distribute horizontally */
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            padding: 0 50px;
            /* Add padding */
            box-sizing: border-box;
        }

        .start-left {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .start-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            /* height: 80%; Removed */
            /* flex: 1; Removed */
            position: relative;
        }

        .start-right {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .logo-icon {
            width: 120px;
            image-rendering: pixelated;
            animation: float 3s ease-in-out infinite;
            margin-bottom: 20px;
        }

        .logo-text {
            width: 300px;
            image-rendering: pixelated;
        }

        .anim-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: balance 2s ease-in-out infinite alternate;
            transform-origin: bottom center;
        }

        .char-owl {
            width: 250px;
            image-rendering: pixelated;
            z-index: 2;
            position: relative;
            top: 63px;
            /* Animation removed */
        }

        /* @keyframes flutter removed */

        /* Updated */

        .char-stack {
            /* width: 150px; Removed */
            height: 570px;
            /* Added */
            image-rendering: pixelated;
            /* margin-top: -10px; Removed */
            /* Synced animation */
            /* Pivot from bottom */
        }

        .start-btn {
            background: linear-gradient(180deg, #ff00cc, #ff6600);
            border: 4px solid #330066;
            box-shadow: 6px 6px 0px #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            padding: 25px 50px;
            /* Larger button */
            font-size: 28px;
            cursor: pointer;
            text-transform: uppercase;
            text-shadow: 3px 3px 0px #330066;
            transition: transform 0.1s;
        }

        .start-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 2px 2px 0px #000;
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }

            100% {
                transform: translateY(0px);
            }
        }

        @keyframes balance {
            0% {
                transform: rotate(-5deg);
            }

            100% {
                transform: rotate(5deg);
            }
        }

        100% {
            transform: rotate(5deg);
        }
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
        }

        .hidden {
            display: none !important;
        }

        /* Name Input Styles */
        #name-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            /* Center inputs */
        }



        .char-input {
            width: 40px;
            height: 50px;
            background: transparent;
            border: 2px solid #fff;
            color: #00ffff;
            /* Neon Blue */
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            text-align: center;
            text-transform: uppercase;
            outline: none;
            caret-color: transparent;
        }

        .char-input:focus {
            outline: none;
            border-color: #00ffff;
            animation: blink-focus 1s infinite;
        }

        @keyframes blink-focus {

            0%,
            100% {
                border-color: #00ffff;
            }

            50% {
                border-color: transparent;
            }
        }

        /* Admin Panel */
        #admin-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 1000;
            opacity: 0.5;
        }

        #admin-btn:hover {
            opacity: 1;
        }

        /* Admin Palette (Neon Blue Theme) */
        :root {
            --gb-darkest: #000a2e;
            /* Deep Blue */
            --gb-dark: #1a1a40;
            /* Panel/Input BG */
            --gb-lightest: #00ffff;
            /* Neon Text/Border */
            --gb-bg: #0f0f1e;
            /* Main Overlay BG */
        }

        #admin-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gb-bg);
            z-index: 1001;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            pointer-events: auto;
            font-family: 'Press Start 2P', cursive;
            color: var(--gb-lightest);
            /* Changed to Lightest */
        }

        #admin-panel input {
            font-family: 'Press Start 2P', cursive;
            padding: 5px;
            margin-bottom: 5px;
            width: 100%;
            box-sizing: border-box;
            background: var(--gb-dark);
            /* Dark BG for inputs */
            color: #fff;
            /* White text for inputs */
            border: 1px solid var(--gb-lightest);
            /* Neon border */
        }

        #admin-panel label {
            font-size: 12px;
            color: var(--gb-lightest);
            /* Changed to Lightest */
            display: block;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .admin-header {
            color: var(--gb-lightest);
            /* Changed to Lightest */
            font-size: 32px;
            text-align: left;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .section-title {
            color: var(--gb-lightest);
            /* Changed to Lightest */
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            text-align: left;
            border-bottom: 2px solid var(--gb-lightest);
            /* Changed to Lightest */
            padding-bottom: 5px;
            width: 100%;
        }

        .admin-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 12px;
            border: 2px solid var(--gb-lightest);
            /* Changed to Lightest */
        }

        .admin-table th {
            text-align: left;
            padding: 10px;
            border: 1px solid var(--gb-lightest);
            background: var(--gb-dark);
            color: var(--gb-lightest);
        }

        .admin-table td {
            padding: 10px;
            border: 1px solid var(--gb-lightest);
            vertical-align: middle;
            background: transparent;
            color: #fff;
        }

        .admin-table input {
            width: 100%;
            background: var(--gb-dark);
            border: 1px solid var(--gb-lightest);
            color: #fff;
            padding: 5px;
            font-family: 'Press Start 2P', cursive;
            box-shadow: none;
        }

        .badge {
            display: inline-block;
            padding: 5px 10px;
            color: #fff;
            font-size: 10px;
            text-transform: uppercase;
            border: 1px solid #fff;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
        }

        .badge-normal {
            background-color: #4a6d8c;
            /* Muted Blue */
        }

        .badge-heavy {
            background-color: #8c4a4a;
            /* Muted Red */
        }

        .admin-footer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: auto;
            gap: 20px;
        }

        .gb-input {
            width: 100%;
            background: var(--gb-dark);
            color: #fff;
            border: 1px solid var(--gb-lightest);
            padding: 10px;
            font-family: 'Press Start 2P';
            box-shadow: none;
        }

        .gb-btn {
            background-color: transparent;
            border: 2px solid var(--gb-lightest);
            box-shadow: none;
            color: var(--gb-lightest);
            font-family: 'Press Start 2P', cursive;
            padding: 15px 20px;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            flex: 1;
            transition: all 0.2s;
        }

        .gb-btn:hover {
            background-color: var(--gb-lightest);
            color: var(--gb-darkest);
        }

        .gb-btn:active {
            transform: translate(2px, 2px);
        }

        /* Responsive Adjustments */
        .table-container {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: auto;
            width: 100%;
            border: 2px solid var(--gb-darkest);
            margin-bottom: 20px;
        }

        .admin-controls-container {
            width: 95%;
            height: 95%;
            display: flex;
            flex-direction: column;
            max-width: none;
            /* Fluid */
        }

        @media (max-width: 768px) {
            .admin-header {
                font-size: 20px;
            }

            .section-title {
                font-size: 14px;
            }

            .gb-btn {
                padding: 10px;
                font-size: 10px;
            }

            .admin-table th,
            .admin-table td {
                padding: 5px;
                font-size: 10px;
            }

            .global-config-row {
                flex-direction: column;
                gap: 10px;
            }
        }



        /* Falling Broken Boxes */
        .falling-box {
            position: absolute;
            background-color: #fff;
            opacity: 0.3;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes fall {
            to {
                transform: translateY(110vh) rotate(360deg);
            }
        }

        @keyframes pulse-grow {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes pulse-shrink {

            0%,
            100% {
                transform: scale(1.1);
            }

            50% {
                transform: scale(1);
            }
        }
    </style>
</head>

<body>

    <div id="game-container"></div>

    <!-- UI Layer -->
    <div class="ui-layer">
        <div style="display: flex; justify-content: space-between; width: 100%;">
            <div id="score-display">SCORE: 0</div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <div class="start-left">
            <img src="assets/start_screen/logo_icon.png" class="logo-icon" alt="Icon">
            <img src="assets/start_screen/logo_text.png" class="logo-text" alt="Ruti Stack">
        </div>
        <div class="start-center">
            <div class="anim-container">
                <img src="assets/start_screen/owl.png" class="char-owl" alt="Owl">
                <img src="assets/start_screen/stack.png" class="char-stack" alt="Stack">
            </div>
        </div>
        <div class="start-right">
            <button class="start-btn" id="play-btn">JOGAR</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden"
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: #000a2e; background-image: url('assets/start_screen/background.png'); background-size: cover; background-position: center; overflow: hidden;">

        <!-- Content Wrapper (Above Falling Boxes) -->
        <div
            style="position: relative; z-index: 10; display: flex; flex-direction: column; align-items: center; gap: 48px; width: 100%;">

            <!-- Group 1: Image -->
            <div style="display: flex; gap: 20px; align-items: center; justify-content: center;">
                <img src="assets/game_over/game_text.png" alt="GAME"
                    style="width: 40%; max-width: 200px; image-rendering: pixelated; animation: pulse-grow 2s infinite ease-in-out;">
                <img src="assets/game_over/over_text.png" alt="OVER"
                    style="width: 40%; max-width: 200px; image-rendering: pixelated; animation: pulse-shrink 2s infinite ease-in-out;">
            </div>

            <!-- Group 2: Score -->
            <div id="final-score" style="font-size: 48px; color: #fff; text-shadow: 4px 4px 0px #000;">SCORE: 0</div>

            <!-- Group 3: Nickname & Save (Bordered Box) -->
            <div
                style="border: 4px solid #fff; padding: 20px; background: rgba(0,0,0,0.5); display: flex; flex-direction: column; align-items: center; gap: 15px;">
                <div style="color: #fff; font-size: 20px; margin-bottom: 5px; font-family: 'Press Start 2P', cursive;">
                    APELIDO</div>

                <div class="input-group">
                    <input type="text" maxlength="1" class="char-input" id="char1">
                    <input type="text" maxlength="1" class="char-input" id="char2">
                    <input type="text" maxlength="1" class="char-input" id="char3">
                    <input type="text" maxlength="1" class="char-input" id="char4">
                    <input type="text" maxlength="1" class="char-input" id="char5">
                </div>

                <button class="pixel-btn" id="save-score-btn"
                    style="width: 100%; font-size: 18px; background: transparent; border: 4px solid #fff; color: #fff;">SALVAR
                    SCORE</button>
                <button class="pixel-btn" id="clear-btn"
                    style="width: 100%; font-size: 14px; background: transparent; border: 2px solid #ff4444; color: #ff4444; margin-top: 10px;">LIMPAR</button>
            </div>

            <!-- Group 4: Restart Button -->
            <button class="menu-btn" id="restart-btn" style="margin-top: 20px;">TENTAR DE NOVO (R)</button>
        </div>
    </div>

    <!-- Admin Button & Panel -->
    <div id="admin-btn">⚙️</div>
    <div id="admin-panel">
        <div id="admin-controls" class="admin-controls-container">
            <!-- Dynamic Content -->
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, addDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        // --- FIREBASE CONFIGURATION ---
        // COLE SUA FIREBASE CONFIG AQUI
        const firebaseConfig = {
            apiKey: "AIzaSyCOAt0sfrDXeZgRYwA5UuTxayX3rr0ubyY",
            authDomain: "rutistack-c75f2.firebaseapp.com",
            projectId: "rutistack-c75f2",
            storageBucket: "rutistack-c75f2.firebasestorage.app",
            messagingSenderId: "401193886438",
            appId: "1:401193886438:web:5279b37e344ecfbbd35127",
            measurementId: "G-5NW50RJQN7"
        };

        let app, db, auth;
        let isFirebaseReady = false;

        try {
            if (firebaseConfig.apiKey) {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                isFirebaseReady = true;
                console.log("Firebase initialized.");
            } else {
                console.warn("Firebase config missing. Running in offline mode.");
            }
        } catch (e) {
            console.error("Firebase init error:", e);
        }

        // --- GAME CONFIGURATION ---
        let gameConfig = {
            gravity: 1,
            baseSpeed: 2,
            difficultyMultiplier: 0.1
        };

        // Fetch Remote Config
        // Fetch Remote Config
        async function loadGameConfig() {
            // 1. Load Local (Fallback/Cache)
            const localConfig = localStorage.getItem('gameConfig');
            if (localConfig) {
                gameConfig = { ...gameConfig, ...JSON.parse(localConfig) };
                console.log("Local config loaded (cache):", gameConfig);
            }
            const localBoxTypes = localStorage.getItem('boxTypes');
            if (localBoxTypes) {
                boxTypes = JSON.parse(localBoxTypes);
                console.log("Local box types loaded (cache):", boxTypes);
            }

            if (!isFirebaseReady) return;

            try {
                // 2. Load Global Config from Firestore
                const configRef = doc(db, "settings", "gameConfig");
                const configSnap = await getDoc(configRef);

                if (configSnap.exists()) {
                    const data = configSnap.data();
                    gameConfig = { ...gameConfig, ...data };
                    console.log("Remote config loaded:", gameConfig);
                    localStorage.setItem('gameConfig', JSON.stringify(gameConfig));
                } else {
                    // Create default if not exists
                    await setDoc(configRef, gameConfig);
                    console.log("Remote config created with defaults.");
                }

                // 3. Load Box Types from Firestore
                const boxesRef = doc(db, "settings", "boxTypes");
                const boxesSnap = await getDoc(boxesRef);

                if (boxesSnap.exists()) {
                    const data = boxesSnap.data();
                    if (data.types) {
                        boxTypes = data.types;
                        console.log("Remote box types loaded:", boxTypes);
                        localStorage.setItem('boxTypes', JSON.stringify(boxTypes));
                    }
                } else {
                    // Create default
                    await setDoc(boxesRef, { types: boxTypes });
                    console.log("Remote box types created with defaults.");
                }

            } catch (e) {
                console.error("Remote config error:", e);
            }
        }

        // --- PHASER GAME ---
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game-container',
            backgroundColor: '#0f0f1e',
            physics: {
                default: 'matter',
                matter: {
                    gravity: { y: 1 }, // Will be updated by gameConfig
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        let game;
        let crane;
        let currentBox = null;
        let fallingBox = null; // Track the box currently falling
        let boxes = [];
        let isGameActive = false;
        let score = 0;
        let craneSpeed = 2;
        const CRANE_Y = -50; // Absolute top (visual offset handled in update)

        // Box Configuration (Data-Driven)
        // Box Configuration (Data-Driven)
        let defaultBoxTypes = [
            {
                id: 'normal',
                name: 'Caixa Normal',
                chance: 90,
                textures: ['box_normal_1', 'box_normal_2', 'box_normal_3'], // Array of texture keys
                width: 128,
                height: 128,
                density: 0.01,
                friction: 0.5,
                bounce: 0.1
            },
            {
                id: 'heavy',
                name: 'Caixa Pesada',
                chance: 10,
                textures: ['box_heavy_1', 'box_heavy_2'],
                width: 180,
                height: 80,
                density: 0.05,
                friction: 0.5,
                bounce: 0.1
            }
        ];

        // Load box config from local storage or use default
        let boxTypes = JSON.parse(localStorage.getItem('boxTypes')) || JSON.parse(JSON.stringify(defaultBoxTypes));

        // DATA MIGRATION: Ensure 'textures' array exists for old saves
        boxTypes.forEach(type => {
            if (!type.textures || type.textures.length === 0) {
                const def = defaultBoxTypes.find(t => t.id === type.id);
                if (def) {
                    type.textures = [...def.textures];
                } else {
                    type.textures = [type.texture || 'box'];
                }
            }
        });

        let ropeGraphics;
        let swingTime = 0;
        let owl, buttonSprite, wingSprite;
        let background; // TileSprite

        function initGame() {
            if (game) return;
            game = new Phaser.Game(config);
        }

        function preload() {
            const graphics = this.make.graphics({ x: 0, y: 0, add: false });

            // Box Texture (Placeholder for Sprite)
            // Box Textures (Placeholders)
            graphics.clear();
            graphics.fillStyle(0xFFFFFF);
            graphics.fillRect(0, 0, 128, 128);
            graphics.generateTexture('box_normal_1', 128, 128);

            graphics.clear();
            graphics.fillStyle(0xEEEEEE); // Slightly different shade
            graphics.fillRect(0, 0, 128, 128);
            graphics.generateTexture('box_normal_2', 128, 128);

            graphics.clear();
            graphics.fillStyle(0xDDDDDD);
            graphics.fillRect(0, 0, 128, 128);
            graphics.generateTexture('box_normal_3', 128, 128);

            // Heavy Box Textures
            graphics.clear();
            graphics.fillStyle(0xFFFFFF);
            graphics.fillRect(0, 0, 180, 80);
            graphics.generateTexture('box_heavy_1', 180, 80);

            graphics.clear();
            graphics.fillStyle(0xCCCCCC);
            graphics.fillRect(0, 0, 180, 80);
            graphics.generateTexture('box_heavy_2', 180, 80);

            // 2. Crane (Simple Gray)
            graphics.clear();
            graphics.fillStyle(0x888888);
            graphics.fillRect(0, 0, 20, 100); // Main vertical pole
            graphics.fillStyle(0x555555);
            graphics.fillRect(-10, 80, 40, 20); // Bottom weight
            graphics.generateTexture('crane', 40, 100);

            // 4. Platform (Full Width & Height)
            graphics.clear();
            graphics.fillStyle(0x555555); // Gray
            graphics.fillRect(0, 0, 2000, 100); // Taller to cover bottom
            graphics.lineStyle(4, 0x333333);
            graphics.strokeRect(0, 0, 2000, 100);
            graphics.generateTexture('platform', 2000, 100);

            // 5. Owl (Happy) - Improved
            graphics.clear();
            // Body
            graphics.fillStyle(0x8B4513);
            graphics.fillRoundedRect(10, 10, 60, 80, 20);
            // Ears
            graphics.beginPath();
            graphics.moveTo(10, 10); graphics.lineTo(0, -10); graphics.lineTo(30, 10);
            graphics.moveTo(70, 10); graphics.lineTo(80, -10); graphics.lineTo(50, 10);
            graphics.fillPath();
            // Belly
            graphics.fillStyle(0xD2B48C);
            graphics.fillEllipse(40, 60, 25, 30);
            // Eyes (Big & Cute)
            graphics.fillStyle(0xFFFFFF);
            graphics.fillCircle(25, 35, 12);
            graphics.fillCircle(55, 35, 12);
            graphics.fillStyle(0x000000);
            graphics.fillCircle(25, 35, 5);
            graphics.fillCircle(55, 35, 5);
            graphics.fillStyle(0xFFFFFF); // Shine
            graphics.fillCircle(27, 33, 2);
            graphics.fillCircle(57, 33, 2);
            // Beak
            graphics.fillStyle(0xFFA500);
            graphics.beginPath();
            graphics.moveTo(35, 45); graphics.lineTo(45, 45); graphics.lineTo(40, 55);
            graphics.fillPath();
            graphics.generateTexture('owl_happy', 80, 100);

            // 6. Owl (Fearful) - Improved
            graphics.clear();
            // Body
            graphics.fillStyle(0x8B4513);
            graphics.fillRoundedRect(10, 10, 60, 80, 20);
            // Ears (Flattened)
            graphics.beginPath();
            graphics.moveTo(10, 10); graphics.lineTo(5, 0); graphics.lineTo(30, 10);
            graphics.moveTo(70, 10); graphics.lineTo(75, 0); graphics.lineTo(50, 10);
            graphics.fillPath();
            // Belly
            graphics.fillStyle(0xD2B48C);
            graphics.fillEllipse(40, 60, 25, 30);
            // Eyes (Wide)
            graphics.fillStyle(0xFFFFFF);
            graphics.fillCircle(25, 35, 14);
            graphics.fillCircle(55, 35, 14);
            graphics.fillStyle(0x000000);
            graphics.fillCircle(25, 35, 3); // Tiny pupils
            graphics.fillCircle(55, 35, 3);
            // Beak (Open)
            graphics.fillStyle(0xFFA500);
            graphics.fillCircle(40, 50, 5);
            graphics.generateTexture('owl_fear', 80, 100);

            // Wing
            graphics.clear();
            graphics.fillStyle(0x654321);
            graphics.fillEllipse(20, 12, 20, 12);
            graphics.generateTexture('wing', 40, 25);

            // Owl Frame (Retro Green Monitor)
            graphics.clear();
            // Casing
            graphics.fillStyle(0x004400); // Dark Green
            graphics.fillRoundedRect(0, 0, 140, 140, 15);
            // Bezel
            graphics.fillStyle(0x002200); // Darker Green
            graphics.fillRoundedRect(10, 10, 120, 120, 5);
            // Screen
            graphics.fillStyle(0x001100); // Almost Black Green
            graphics.fillRect(15, 15, 110, 110);
            // Scanlines
            graphics.fillStyle(0x00FF00);
            graphics.globalAlpha = 0.1;
            for (let y = 15; y < 125; y += 2) {
                graphics.fillRect(15, y, 110, 1);
            }
            graphics.globalAlpha = 1.0;
            graphics.generateTexture('owl_frame', 140, 140);

            // Buildings Texture (Taller, No Windows)
            graphics.clear();
            graphics.fillStyle(0x1a1a2e); // Dark Blue/Gray
            for (let i = 0; i < 15; i++) {
                const h = Phaser.Math.Between(100, 400); // Taller
                const w = Phaser.Math.Between(40, 100);
                const x = i * 80;
                graphics.fillRect(x, 512 - h, w, h);
                // No Windows
            }
            graphics.generateTexture('bg_buildings', 1024, 512);

            // Clouds Texture (Tiny)
            graphics.clear();
            // Clouds Texture (Placeholder for Sprite)
            graphics.clear();
            graphics.fillStyle(0xFFFFFF);
            graphics.fillRect(0, 0, 128, 64); // Larger placeholder rect
            graphics.generateTexture('cloud', 128, 64);

            // Background Texture (Stars/Space)
            graphics.clear();
            graphics.fillStyle(0x0f0f1e);
            graphics.fillRect(0, 0, 512, 512);
            graphics.fillStyle(0xFFFFFF);
            for (let i = 0; i < 50; i++) {
                graphics.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }
            graphics.generateTexture('bg_stars', 512, 512);
        }

        function create() {
            const { width, height } = this.scale;

            // Set bounds
            this.matter.world.setBounds(0, -100000, width, height + 200000, 64, true, true, false, false);
            this.matter.world.setGravity(0, gameConfig.gravity);

            // Background (Stars)
            background = this.add.tileSprite(width / 2, height / 2, width, height, 'bg_stars');
            background.setScrollFactor(0);
            background.setDepth(-100);

            // Clouds (Sparse Group)
            this.clouds = this.add.group();
            // Create fewer clouds, spread out
            for (let i = 0; i < 6; i++) {
                const x = Phaser.Math.Between(0, width);
                // Spread from bottom (height) to way up (-2000)
                const y = Phaser.Math.Between(-2000, height);
                const cloud = this.add.image(x, y, 'cloud');
                cloud.setDepth(-95);
                cloud.setAlpha(1.0); // Fully visible placeholder
                cloud.setScrollFactor(0.5); // Parallax
                this.clouds.add(cloud);
            }

            // Buildings (Image, not TileSprite, to avoid looping)
            // Anchored at bottom, moves with parallax
            const buildings = this.add.image(width / 2, height, 'bg_buildings');
            buildings.setOrigin(0.5, 1); // Bottom center
            buildings.setScrollFactor(0.1); // Moves slowly
            buildings.setDepth(-90);
            buildings.setName('buildings');

            // Platform
            const platform = this.matter.add.image(width / 2, height - 50, 'platform', null, { isStatic: true });
            platform.setDisplaySize(width, 100);
            platform.setDepth(5);

            // Crane
            crane = this.add.image(width / 2, CRANE_Y, 'crane');
            crane.setDepth(10);
            crane.setVisible(false); // Hide the crane pole, keep only rope

            ropeGraphics = this.add.graphics();
            ropeGraphics.setDepth(9);

            // UI Elements
            // Monitor Frame
            const frameX = width - 80;
            const frameY = height - 80;

            const owlFrame = this.add.image(frameX, frameY, 'owl_frame');
            owlFrame.setScrollFactor(0);
            owlFrame.setDepth(19);

            // Owl inside screen
            owl = this.add.image(frameX, frameY, 'owl_happy');
            owl.setScrollFactor(0);
            owl.setDepth(20);
            owl.setScale(0.9);
            owl.setTint(0x88FF88); // Greenish tint for retro monitor effect

            wingSprite = this.add.image(frameX - 30, frameY + 10, 'wing');
            wingSprite.setScrollFactor(0);
            wingSprite.setDepth(21);
            wingSprite.setOrigin(1, 0.5);
            wingSprite.setTint(0x88FF88);

            const btnText = this.add.text(width - 80, height - 185, 'DROP', {
                fontFamily: '"Press Start 2P"', fontSize: '14px', color: '#000000'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(21);

            // Height Display (Single Line)
            this.add.text(20, 50, 'ALTURA: 0m', { fontFamily: '"Press Start 2P"', fontSize: '16px', color: '#ffffff' })
                .setName('heightDisplay')
                .setScrollFactor(0);

            const instructionText = this.add.text(width / 2, height - 50, 'CLIQUE PARA SOLTAR', {
                fontFamily: '"Press Start 2P"',
                fontSize: '12px',
                color: '#ffffff'
            });
            instructionText.setOrigin(0.5);
            instructionText.setScrollFactor(0);
            instructionText.setDepth(30);
            instructionText.setName('instructionText');

            // Update Restart Button Text
            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) restartBtn.innerText = "TENTAR DE NOVO (ESPAÇO)";

            // Input
            this.input.on('pointerdown', () => {
                if (isGameActive && currentBox && !fallingBox) {
                    dropBox(this);

                    // Animate Wing
                    this.tweens.add({ targets: wingSprite, angle: -45, duration: 100, yoyo: true });
                }
            });

            // Keyboard Shortcuts
            this.input.keyboard.on('keydown-SPACE', () => {
                console.log('SPACE pressed');
                console.log('State:', { isGameActive, currentBox: !!currentBox, fallingBox: !!fallingBox });

                if (isGameActive && currentBox && !fallingBox) {
                    console.log('Action: Drop Box');
                    dropBox(this);
                    this.tweens.add({
                        targets: wingSprite,
                        angle: -45,
                        x: frameX + 30,
                        y: frameY + 40,
                        duration: 100,
                        yoyo: true,
                        onComplete: () => {
                            wingSprite.setPosition(frameX - 30, frameY + 10);
                        }
                    });
                } else {
                    // Global Space Handler
                    const startScreen = document.getElementById('start-screen');
                    const gameOverScreen = document.getElementById('game-over-screen');

                    // Check visibility
                    // Note: .style.display might be empty string if set via CSS class
                    const startScreenVisible = startScreen && getComputedStyle(startScreen).display !== 'none';
                    const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');

                    console.log('Screens:', { startScreenVisible, gameOverVisible });

                    if (startScreenVisible) {
                        console.log('Action: Start Game (from Start Screen)');
                        startGame();
                    } else if (gameOverVisible) {
                        console.log('Action: Start Game (from Game Over)');
                        startGame();
                    }
                }
            });

            this.input.keyboard.on('keydown-ENTER', () => {
                console.log('ENTER pressed');
                const gameOverScreen = document.getElementById('game-over-screen');
                const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');

                console.log('State:', { isGameActive, gameOverVisible });

                if (!isGameActive && gameOverVisible) {
                    console.log('Action: Start Game (from Game Over)');
                    startGame();
                }
            });// Collision (Freeze Logic & Game Over)
            this.matter.world.on('collisionstart', (event) => {
                event.pairs.forEach(pair => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    // Check for Game Over condition: Box hitting the platform when it's not the first box
                    if (bodyA.gameObject === platform || bodyB.gameObject === platform) {
                        const otherBody = bodyA.gameObject === platform ? bodyB : bodyA;
                        if (otherBody && otherBody.gameObject && boxes.includes(otherBody.gameObject)) {
                            // If it's NOT the first box (index 0), then it fell on the floor -> Game Over
                            if (boxes.indexOf(otherBody.gameObject) > 0) {
                                gameOver();
                                return; // Stop processing this collision as game is over
                            }
                        }
                    }

                    [bodyA, bodyB].forEach(body => {
                        if (body.gameObject && boxes.includes(body.gameObject) && !body.isStatic) {
                            if (!body.gameObject.isFreezing) {
                                body.gameObject.isFreezing = true;
                                this.time.delayedCall(1000, () => {
                                    if (body.gameObject && body.gameObject.body) {
                                        if (body.speed < 0.5 && Math.abs(body.angularVelocity) < 0.05) {
                                            body.gameObject.setStatic(true);
                                            body.gameObject.setRotation(0);
                                        } else {
                                            body.gameObject.isFreezing = false;
                                        }
                                    }
                                });
                            }
                        }
                    });
                });
            });

            this.scene.pause();
        }

        function update(time, delta) {
            if (!isGameActive) return;

            const { width, height } = this.scale;

            // Scroll Backgrounds
            background.tilePositionY = this.cameras.main.scrollY * 0.1;

            // Buildings: Image with scrollFactor handles itself. No manual update needed.

            // Hide Instruction
            const instructionText = this.children.getByName('instructionText');
            if (instructionText) {
                instructionText.setVisible(this.cameras.main.scrollY === 0);
            }

            // 1. Game Logic: Spawn new box if falling box is done
            if (fallingBox) {
                // If falling box is static (landed)
                if (fallingBox.body.isStatic) {
                    fallingBox = null;
                    spawnBox(this);
                }
                // Removed the out of bounds check here, as platform collision handles it now.
            }

            // 2. Calculate Tower Stats (Height & Stability)
            let highestStaticY = height - 100; // Start at platform level
            let totalDeviation = 0;
            let staticBoxCount = 0;

            boxes.forEach(box => {
                // Ignore the current box being carried by the crane!
                if (box !== currentBox) {
                    // Check for fall (Game Over)
                    // Fix: Only check if the box is NOT static (i.e., it's falling)
                    // Static boxes are part of the stack and are allowed to go off-screen
                    if (!box.body.isStatic && box.y > this.cameras.main.scrollY + height + 200) {
                        // Only if it's not the first box (which is on the platform)
                        // But wait, the platform is at height-50.
                        // If a box falls off the stack, it will go down.
                        // If it's index > 0 and y > height - 50 + buffer, it missed the stack.
                        if (boxes.indexOf(box) > 0) {
                            // console.log('Box fell off stack!');
                            gameOver();
                            return;
                        }
                    }

                    if (box.body && box.body.isStatic) {
                        if (box.y < highestStaticY) highestStaticY = box.y;
                        totalDeviation += Math.abs(box.x - width / 2);
                        staticBoxCount++;
                    }
                }
            });

            // Update Height UI
            const towerHeight = Math.max(0, Math.floor((height - 100 - highestStaticY) / 128));
            const heightText = this.children.getByName('heightDisplay');
            if (heightText) heightText.setText('ALTURA: ' + towerHeight + 'm');

            // Update Owl Expression
            const avgDeviation = staticBoxCount > 0 ? totalDeviation / staticBoxCount : 0;
            if (avgDeviation > 20) { // Threshold for "fear"
                owl.setTexture('owl_fear');
            } else {
                owl.setTexture('owl_happy');
            }

            // 3. Camera Follow (Lazy Follow)
            if (!fallingBox) {
                const minGap = 600; // Increased gap (earlier scroll)
                const currentCraneY = this.cameras.main.scrollY + 50;

                // If stack is too close to crane (highestStaticY is smaller than craneY + gap)
                if (highestStaticY < currentCraneY + minGap) {
                    const targetCamY = highestStaticY - minGap - 50;
                    this.cameras.main.scrollY += (targetCamY - this.cameras.main.scrollY) * 0.05;
                }
            }

            // 4. Crane Position (Always above camera view)
            // Crane stays at fixed relative position to camera top, or follows tower?
            // User asked for "topo zero da tela".
            // So crane.y should be camera.scrollY
            crane.y = this.cameras.main.scrollY;

            // 5. Rope & Swing
            ropeGraphics.clear();
            if (currentBox && currentBox.isCarried) {
                swingTime += delta * (craneSpeed * 0.0005);
                const ropeLength = 250; // Longer rope since it starts from top
                const maxSwingAngle = 0.6; // Reduced from 1.0 to be less wide
                const angle = Math.sin(swingTime) * maxSwingAngle;

                const ropeEndX = crane.x + Math.sin(angle) * ropeLength;
                const ropeEndY = crane.y + Math.cos(angle) * ropeLength;

                const boxX = ropeEndX + Math.sin(angle) * 64;
                const boxY = ropeEndY + Math.cos(angle) * 64;

                currentBox.setPosition(boxX, boxY);
                currentBox.setRotation(0); // NO ROTATION on crane

                // Analytical Velocity Calculation (Derivative)
                // Theta = sin(swingTime) * maxSwingAngle
                // dTheta/dt = cos(swingTime) * maxSwingAngle * speedFactor
                const speedFactor = craneSpeed * 0.0005;
                const dThetaDt = Math.cos(swingTime) * maxSwingAngle * speedFactor; // rad/ms

                // Vx = L * cos(Theta) * dTheta/dt
                // Vy = -L * sin(Theta) * dTheta/dt
                // Multiply by 16.66 to convert px/ms to px/frame (Matter.js units)
                const frameTime = 16.66;
                currentBox.swingVelX = (ropeLength * Math.cos(angle) * dThetaDt) * frameTime;
                currentBox.swingVelY = (ropeLength * -Math.sin(angle) * dThetaDt) * frameTime;

                ropeGraphics.lineStyle(4, 0xffffff);
                ropeGraphics.beginPath();
                ropeGraphics.moveTo(crane.x, crane.y); // Start exactly at top
                ropeGraphics.lineTo(ropeEndX, ropeEndY);
                ropeGraphics.strokePath();
            }
        }
        function spawnBox(scene) {
            if (!isGameActive) return;
            if (currentBox) return;

            const { width } = scene.scale;

            // Select Box Type based on Chance
            // First box always Normal if possible, or just random?
            // User previously wanted first box not to be heavy.
            // Let's filter for 'normal' type for first box if it exists.

            let selectedType;
            if (boxes.length === 0) {
                selectedType = boxTypes.find(t => t.id === 'normal') || boxTypes[0];
            } else {
                const totalChance = boxTypes.reduce((sum, t) => sum + t.chance, 0);
                let random = Phaser.Math.Between(0, totalChance);
                for (const type of boxTypes) {
                    if (random <= type.chance) {
                        selectedType = type;
                        break;
                    }
                    random -= type.chance;
                }
                if (!selectedType) selectedType = boxTypes[0]; // Fallback
            }

            // Select Random Texture from the list
            const textureList = selectedType.textures || [selectedType.texture]; // Fallback for old config
            let textureKey = Phaser.Utils.Array.GetRandom(textureList);

            // Check for custom texture (if user uploaded one)
            // Logic update: Custom textures overwrite specific slots.
            // e.g. box_normal_1_custom
            if (scene.textures.exists(textureKey + '_custom')) {
                textureKey = textureKey + '_custom';
            }

            // Spawn at crane position
            const box = scene.matter.add.image(width / 2, crane.y + 250, textureKey);

            // Apply Physics Properties
            box.setRectangle(selectedType.width, selectedType.height);
            box.setDisplaySize(selectedType.width, selectedType.height); // Match visual to physics
            box.setDensity(selectedType.density);
            box.setFriction(selectedType.friction);
            box.setBounce(selectedType.bounce);

            box.boxTypeId = selectedType.id; // Store type ID for reference

            box.setIgnoreGravity(true); // Ignore gravity while carried

            box.isCarried = true;
            box.swingVelX = 0;
            box.swingVelY = 0;

            currentBox = box;
            boxes.push(box);
        }

        function dropBox(scene) {
            if (!currentBox || isDropping) return;

            isDropping = true;
            logEvent('DROP_BOX', { x: crane.x, y: crane.y, angle: currentBox.rotation }); // Use currentBox.rotation for angle

            currentBox.isCarried = false;
            currentBox.setIgnoreGravity(false);

            // Apply calculated analytical velocity
            currentBox.setVelocity(currentBox.swingVelX, currentBox.swingVelY);

            fallingBox = currentBox;
            currentBox = null;

            score++;
            document.getElementById('score-display').innerText = 'SCORE: ' + score;

            // Increase difficulty
            const speedIncrease = score * gameConfig.difficultyMultiplier;
            craneSpeed = gameConfig.baseSpeed + speedIncrease;

            // Spawn next box after delay
            scene.time.delayedCall(1000, () => {
                if (isGameActive) spawnBox(scene);
            });
        }


        function startGame() {
            console.log('Starting Game...');
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');

            isGameActive = true;
            score = 0;
            craneSpeed = gameConfig.baseSpeed;

            if (game) {
                const scene = game.scene.scenes[0];

                // 1. Destroy all existing boxes
                boxes.forEach(box => {
                    if (box) {
                        scene.matter.world.remove(box);
                        if (box.destroy) box.destroy();
                    }
                });
                boxes = [];

                // 2. Destroy current/falling boxes if they exist
                if (currentBox) {
                    scene.matter.world.remove(currentBox);
                    if (currentBox.destroy) currentBox.destroy();
                    currentBox = null;
                }
                if (fallingBox) {
                    scene.matter.world.remove(fallingBox);
                    if (fallingBox.destroy) fallingBox.destroy();
                    fallingBox = null;
                }

                scene.scene.resume();
                scene.cameras.main.scrollY = 0; // Reset Camera
                if (background) background.tilePositionY = 0;
                crane.y = CRANE_Y; // Reset Crane

                document.getElementById('score-display').innerText = 'SCORE: 0';

                // Reset physics gravity in case it changed
                scene.matter.world.setGravity(0, gameConfig.gravity);

                spawnBox(scene);
            } else {
                initGame();
                // Wait for scene to start then spawn
                setTimeout(() => {
                    const scene = game.scene.scenes[0];
                    scene.scene.resume();
                    spawnBox(scene);
                }, 500);
            }
        }

        // --- GAME OVER LOGIC ---
        let gameOverMenuIndex = 0; // 0: Save, 1: Restart
        let fallingBoxesInterval = null;

        function startGameOverRain() {
            if (fallingBoxesInterval) clearInterval(fallingBoxesInterval);

            const container = document.getElementById('game-over-screen');

            fallingBoxesInterval = setInterval(() => {
                if (container.classList.contains('hidden')) return;

                const box = document.createElement('div');
                box.classList.add('falling-box');

                // Random size (tripled: 30-90px)
                const size = Math.random() * 60 + 30;
                box.style.width = size + 'px';
                box.style.height = size + 'px';

                // Random position
                box.style.left = Math.random() * 100 + '%';
                box.style.top = '-100px'; // Start higher up to account for larger size

                // Random animation (slower: 5-10s)
                const duration = Math.random() * 5 + 5;
                box.style.animation = `fall ${duration}s linear forwards`;

                container.appendChild(box);

                // Cleanup
                setTimeout(() => {
                    if (box.parentNode) box.parentNode.removeChild(box);
                }, duration * 1000);

            }, 600); // Spawn every 600ms (slower frequency)
        }

        function stopGameOverRain() {
            if (fallingBoxesInterval) {
                clearInterval(fallingBoxesInterval);
                fallingBoxesInterval = null;
            }
            // Remove all existing boxes
            document.querySelectorAll('.falling-box').forEach(el => el.remove());
        }

        function updateGameOverMenu() {
            const buttons = [document.getElementById('save-score-btn'), document.getElementById('restart-btn')];
            buttons.forEach((btn, index) => {
                if (index === gameOverMenuIndex) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        function gameOver() {
            isGameActive = false;
            if (game) {
                game.scene.pause('default');
            }

            const finalScore = Math.max(0, boxes.length - 1); // Simple score based on boxes
            logEvent('GAME_OVER', { score: finalScore });
            const scoreElement = document.getElementById('final-score');
            if (scoreElement) scoreElement.innerText = 'SCORE: ' + finalScore;

            const gameOverScreen = document.getElementById('game-over-screen');
            if (gameOverScreen) {
                gameOverScreen.classList.remove('hidden');
                gameOverScreen.style.display = 'flex'; // Force display flex

                // Start Rain
                startGameOverRain();

                // Reset Menu
                gameOverMenuIndex = 0;
                updateGameOverMenu();
            }

            const startScreen = document.getElementById('start-screen');
            if (startScreen) {
                startScreen.style.display = 'none'; // Ensure start screen is hidden
            }

            // Focus on first input
            setTimeout(() => {
                const firstInput = document.getElementById('char1');
                if (firstInput) firstInput.focus();
            }, 100);

            logEvent('GAME_OVER', { score: finalScore });
        }

        // --- ANTI-HACK LOG SYSTEM ---
        let gameLog = [];

        function logEvent(action, details = {}) {
            gameLog.push({
                ts: Date.now(),
                action: action,
                ...details
            });
            // console.log('Log:', action, details);
        }

        // Global Keyboard Listener for Game Over Menu
        document.addEventListener('keydown', (e) => {
            const gameOverScreen = document.getElementById('game-over-screen');
            if (!gameOverScreen || gameOverScreen.classList.contains('hidden')) return;

            // If typing in input, ignore arrows unless they are for navigation between inputs (handled by browser)
            // But we want to navigate buttons if inputs are NOT focused or if we press Down from inputs?
            // Let's keep it simple: Up/Down always navigates buttons if we are not typing?
            // Actually user said "using keyboard keys to change selection".

            if (e.key === 'ArrowUp') {
                gameOverMenuIndex = (gameOverMenuIndex - 1 + 2) % 2;
                updateGameOverMenu();
            } else if (e.key === 'ArrowDown') {
                gameOverMenuIndex = (gameOverMenuIndex + 1) % 2;
                updateGameOverMenu();
            } else if (e.key === 'Enter') {
                // Trigger selected button
                if (gameOverMenuIndex === 0) {
                    document.getElementById('save-score-btn').click();
                } else {
                    document.getElementById('restart-btn').click();
                }
            } else if (e.key === ' ' || e.key.toLowerCase() === 'r') {
                // Shortcut: Space or R to Restart immediately (User Request)
                document.getElementById('restart-btn').click();
            }
        });

        // --- UI & ADMIN LOGIC ---

        document.getElementById('play-btn').addEventListener('click', async () => {
            console.log('Play button clicked');
            try {
                // Timeout for config load to prevent hanging
                const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 2000));
                await Promise.race([loadGameConfig(), timeoutPromise]);
            } catch (e) {
                console.warn('Config load skipped or failed:', e);
            }
            console.log('Calling startGame...');
            startGame();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            startGame();
        });

        // Name Input Logic
        const nameInputs = document.querySelectorAll('.char-input');
        nameInputs.forEach((input, index) => {
            input.addEventListener('input', (e) => {
                if (input.value.length === 1) {
                    if (index < nameInputs.length - 1) nameInputs[index + 1].focus();
                }
            });
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Backspace' && input.value.length === 0) {
                    if (index > 0) nameInputs[index - 1].focus();
                }
            });
        });

        document.getElementById('save-score-btn').addEventListener('click', async () => {
            if (playerName.length < 3) {
                alert("Digite um nome com pelo menos 3 letras!");
                return;
            }

            const newScore = {
                name: playerName,
                score: score,
                date: new Date().toLocaleDateString()
            };

            // Save to LocalStorage
            let highScores = JSON.parse(localStorage.getItem('highScores') || '[]');
            highScores.push(newScore);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10); // Keep top 10
            localStorage.setItem('highScores', JSON.stringify(highScores));

            alert(`Recorde Salvo Localmente!\nNome: ${playerName}\nScore: ${score}`);

            // Firebase Logic
            if (!isFirebaseReady) {
                console.warn("Firebase não está pronto. Score salvo apenas localmente.");
                return;
            }

            try {
                // Add a new document with a generated id.
                const docRef = await addDoc(collection(db, "scores"), {
                    name: playerName,
                    score: score,
                    date: new Date().toISOString() // Use ISO string for better sorting/format
                });
                console.log("Document written with ID: ", docRef.id);
                alert(`Recorde Salvo no Firebase!\nID: ${docRef.id}`);
            } catch (e) {
                console.error("Error adding document: ", e);
                alert("Erro ao salvar no Firebase. Verifique o console.");
            }
        });

        // Admin Panel
        const adminPanel = document.getElementById('admin-panel');
        const adminControls = document.getElementById('admin-controls');
        adminControls.className = 'admin-controls-container';
        adminControls.style.width = '95%'; // Ensure fluid width
        adminControls.style.maxWidth = 'none'; // Remove limit

        adminControls.innerHTML = `
            
            <h2 class="section-title">CONFIGURAÇÃO GLOBAL</h2>
            <div class="global-config-row" style="display: flex; gap: 20px; margin-bottom: 30px; width: 100%;">
                <div style="flex: 1;">
                    <label>Gravidade Y</label>
                    <input type="number" id="cfg-gravity" step="0.1" class="gb-input" value="${gameConfig.gravity}">
                </div>
                <div style="flex: 1;">
                    <label>Velocidade Base</label>
                    <input type="number" id="cfg-speed" step="0.1" class="gb-input" value="${gameConfig.baseSpeed}">
                </div>
                <div style="flex: 1;">
                    <label>Mult. Dificuldade</label>
                    <input type="number" id="cfg-diff" step="0.01" class="gb-input" value="${gameConfig.difficultyMultiplier}">
                </div>
            </div>

            <h2 class="section-title">TIPOS DE CAIXA</h2>
            <div id="box-types-list" class="table-container">
                <!-- Dynamic Table Here -->
            </div>

            <div class="admin-footer">
                <button class="gb-btn" id="admin-cancel-btn">CANCELAR</button>
                <button class="gb-btn" id="reset-defaults-btn" style="background-color: #8c4a4a; color: #fff;">RESETAR PADRÕES</button>
                <button class="gb-btn" id="save-global-btn">SALVAR TUDO</button>
            </div>
        `;

        // Password Modal HTML
        const passwordOverlay = document.createElement('div');
        passwordOverlay.id = 'password-overlay';
        passwordOverlay.style.cssText = 'display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;';
        passwordOverlay.innerHTML = `
            <div id="password-modal" class="pixel-box" style="position: relative; min-width: 300px;">
                <h3 style="color: #fff; margin-top: 0;">SENHA ADMIN</h3>
                <input type="password" id="modal-pass" class="char-input" style="width: 90%; margin: 20px 0; font-size: 24px;" placeholder="***">
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="modal-confirm" class="pixel-btn">ACESSAR</button>
                    <button id="modal-close" class="pixel-btn" style="border-color: #ff4444; color: #ff4444;">FECHAR</button>
                </div>
            </div>
        `;
        document.body.appendChild(passwordOverlay);

        // --- DYNAMIC ADMIN PANEL ---

        function renderAdminPanel() {
            const container = document.getElementById('box-types-list');
            container.innerHTML = '';

            const table = document.createElement('table');
            table.className = 'admin-table';

            // Table Header
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Tipo</th>
                        <th>Chance</th>
                        <th>Densidade</th>
                        <th>Largura</th>
                        <th>Altura</th>
                        <th>Atrito</th>
                        <th>Sprites (Upload)</th>
                        <th>Preview</th>
                    </tr>
                </thead>
                <tbody id="admin-table-body"></tbody>
            `;

            container.appendChild(table);
            const tbody = table.querySelector('tbody');

            boxTypes.forEach((type, index) => {
                const tr = document.createElement('tr');

                const badgeClass = type.id === 'heavy' ? 'badge-heavy' : 'badge-normal';
                const badgeName = type.id === 'heavy' ? 'Pesada' : 'Normal';

                // Generate upload inputs for each texture slot
                let spritesHtml = '<div style="display: flex; flex-direction: column; gap: 5px;">';
                const textures = type.textures || [type.texture]; // Handle migration

                spritesHtml += `
                    <input type="file" id="upload-${type.id}" accept="image/*" style="display: none;">
                    <button class="gb-btn" onclick="document.getElementById('upload-${type.id}').click()" style="font-size: 10px; padding: 5px;">Upload</button>
                `;
                spritesHtml += '</div>';

                tr.innerHTML = `
                    <td><span class="badge ${badgeClass}">${badgeName}</span></td>
                    <td><input type="number" class="box-input" data-id="${index}" data-field="chance" value="${type.chance}"></td>
                    <td><input type="number" class="box-input" data-id="${index}" data-field="density" step="0.01" value="${type.density}"></td>
                    <td><input type="number" class="box-input" data-id="${index}" data-field="width" value="${type.width}"></td>
                    <td><input type="number" class="box-input" data-id="${index}" data-field="height" value="${type.height}"></td>
                    <td><input type="number" class="box-input" data-id="${index}" data-field="friction" step="0.1" value="${type.friction}"></td>
                    <td>${spritesHtml}</td>
                    <td style="text-align: center;">
                        <img id="preview-${type.id}" src="${type.textures && type.textures[0] ? type.textures[0] : ''}" 
                             style="width: 50px; height: 50px; object-fit: contain; background: #000; border: 1px solid var(--gb-lightest);">
                    </td>
                `;
                tbody.appendChild(tr);
            });

            // Re-attach sprite upload listeners
            document.querySelectorAll('.sprite-upload').forEach(input => {
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    const textureKey = e.target.dataset.key;
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            if (game) {
                                const customKey = textureKey + '_custom';
                                if (game.textures.exists(customKey)) game.textures.remove(customKey);
                                game.textures.addImage(customKey, img);
                                alert(`Sprite ${textureKey} atualizado!`);
                            }
                        };
                    };
                    reader.readAsDataURL(file);
                });
            });
        }



        // --- DYNAMIC ADMIN PANEL ---

        // Admin Button Logic
        document.getElementById('admin-btn').addEventListener('click', () => {
            console.log('Admin button clicked');
            document.getElementById('password-overlay').style.display = 'flex'; // Show Overlay
            document.getElementById('modal-pass').value = '';
            document.getElementById('modal-pass').focus();
        });

        // Password Modal Logic
        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('password-overlay').style.display = 'none';
        });

        document.getElementById('modal-confirm').addEventListener('click', async () => {
            const pass = document.getElementById('modal-pass').value;
            if (pass === "admin123") { // Hardcoded for now
                document.getElementById('password-overlay').style.display = 'none';

                // Hide other screens for Full Screen Admin
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('game-over-screen').classList.add('hidden');

                // Load latest values from Firestore before showing
                if (isFirebaseReady) {
                    document.body.style.cursor = 'wait';
                    await loadGameConfig();
                    document.body.style.cursor = 'default';
                }

                // Load values and show panel
                renderAdminPanel();
                document.getElementById('cfg-gravity').value = gameConfig.gravity;
                document.getElementById('cfg-speed').value = gameConfig.baseSpeed;
                document.getElementById('cfg-diff').value = gameConfig.difficultyMultiplier;

                const adminPanel = document.getElementById('admin-panel');
                adminPanel.style.display = 'flex';
            } else {
                alert("Senha Incorreta!");
            }
        });

        // Cancel Button Logic
        document.getElementById('admin-cancel-btn').addEventListener('click', () => {
            adminPanel.style.display = 'none';
            // Return to Start Screen
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('game-over-screen').classList.add('hidden'); // Ensure game over is hidden
        });

        // Reset Defaults Logic
        document.getElementById('reset-defaults-btn').addEventListener('click', () => {
            if (confirm("Tem certeza? Isso vai resetar todas as configurações e sprites para o padrão original.")) {
                localStorage.removeItem('gameConfig');
                localStorage.removeItem('boxTypes');
                // Also clear Firestore if needed? Maybe just local for now to fix the view.
                // Let's just reload the page to fetch defaults.
                window.location.reload();
            }
        });    // Return to Start Screen
        document.getElementById('start-screen').classList.remove('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        // Removed old admin-login-btn listener as per instructions.
        // document.getElementById('admin-login-btn').addEventListener('click', () => {
        //     // Password check removed as requested
        //     // const pass = document.getElementById('admin-pass').value;
        //     // if (pass === "admin123") {
        //     adminControls.style.display = 'block';
        //     document.getElementById('admin-login-btn').style.display = 'none';
        //     // Hide password input too since it's not needed
        //     document.getElementById('admin-pass').style.display = 'none';
        //     const passLabel = document.querySelector('label[for="admin-pass"]');
        //     if (passLabel) passLabel.style.display = 'none';

        //     // Load current values into inputs
        //     document.getElementById('cfg-gravity').value = gameConfig.gravity;
        //     document.getElementById('cfg-speed').value = gameConfig.baseSpeed;
        //     document.getElementById('cfg-diff').value = gameConfig.difficultyMultiplier;
        //     // } else {
        //     //     alert("Senha Incorreta!");
        //     // }
        // });

        // Sprite Upload Logic
        // This function is now integrated into renderAdminPanel and its calls are removed.
        // function handleSpriteUpload(inputId, textureKey) {
        //     document.getElementById(inputId).addEventListener('change', (e) => {
        //         const file = e.target.files[0];
        //         if (!file) return;

        //         const reader = new FileReader();
        //         reader.onload = (event) => {
        //             const img = new Image();
        //             img.src = event.target.result;
        //             img.onload = () => {
        //                 if (game) {
        //                     // Add new texture
        //                     const customKey = textureKey + '_custom';
        //                     if (game.textures.exists(customKey)) {
        //                         game.textures.remove(customKey);
        //                     }
        //                     game.textures.addImage(customKey, img);
        //                     alert(`Sprite ${textureKey} atualizado! Próximas caixas usarão o novo sprite.`);
        //                 }
        //             };
        //         };
        //         reader.readAsDataURL(file);
        //     });
        // }

        // handleSpriteUpload('upload-box', 'box');
        // handleSpriteUpload('upload-box-heavy', 'box_heavy');

        // Update Save Logic
        // Update Save Logic
        document.getElementById('save-global-btn').addEventListener('click', async () => {
            // 1. Save Global Config
            const newConfig = {
                gravity: parseFloat(document.getElementById('cfg-gravity').value),
                baseSpeed: parseFloat(document.getElementById('cfg-speed').value),
                difficultyMultiplier: parseFloat(document.getElementById('cfg-diff').value)
            };
            gameConfig = newConfig;
            localStorage.setItem('gameConfig', JSON.stringify(newConfig));

            // 2. Save Box Types
            const rows = document.querySelectorAll('#admin-table-body tr');
            rows.forEach(row => {
                const inputs = row.querySelectorAll('.box-input');
                inputs.forEach(input => {
                    const index = input.dataset.id;
                    const field = input.dataset.field;
                    let value = parseFloat(input.value);
                    if (isNaN(value)) value = 0;

                    boxTypes[index][field] = value;
                });
            });
            localStorage.setItem('boxTypes', JSON.stringify(boxTypes));

            // 3. Save to Firestore
            if (isFirebaseReady) {
                try {
                    const saveBtn = document.getElementById('save-global-btn');
                    const originalText = saveBtn.innerText;
                    saveBtn.innerText = "SALVANDO...";
                    saveBtn.disabled = true;

                    await setDoc(doc(db, "settings", "gameConfig"), newConfig);
                    await setDoc(doc(db, "settings", "boxTypes"), { types: boxTypes });

                    alert("Salvo no Firebase e Localmente!");
                    saveBtn.innerText = originalText;
                    saveBtn.disabled = false;
                } catch (e) {
                    console.error("Firebase save error:", e);
                    alert("Salvo localmente. Erro no Firebase: " + e.message);
                    document.getElementById('save-global-btn').disabled = false;
                }
            } else {
                alert("Salvo Localmente (Offline)!");
            }

            // Apply Physics Immediately
            if (game) {
                const scene = game.scene.scenes[0];
                if (scene) scene.matter.world.setGravity(0, gameConfig.gravity);
            }

            // adminPanel.style.display = 'none'; // Keep panel open (User Request)
        });

        // --- GLOBAL SHORTCUTS (Document Level) ---
        document.addEventListener('keydown', (event) => {
            const key = event.key;
            // console.log('Global Keydown:', key);

            const startScreen = document.getElementById('start-screen');
            const gameOverScreen = document.getElementById('game-over-screen');

            const startVisible = startScreen && getComputedStyle(startScreen).display !== 'none';
            const gameOverVisible = gameOverScreen && !gameOverScreen.classList.contains('hidden');

            if (key === ' ' || key === 'Enter') {
                if (startVisible) {
                    console.log('Global Shortcut: Start Game');
                    startGame();
                    event.preventDefault(); // Prevent scroll
                } else if (gameOverVisible) {
                    console.log('Global Shortcut: Restart Game');
                    startGame();
                    event.preventDefault();
                }
            }
        });

        // Check for Game Over test param
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('gameover') === 'true') {
            // Wait a brief moment for assets/DOM to be ready
            setTimeout(() => {
                gameOver();
            }, 500);
        }
    </script>

</body>

</html>
```